var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
import { Promised } from "../utils/Promised.ts";
import { METHOD } from "./RoutesInit.ts";
const STREAM_ID_KEY = "stream-id";
const STREAM_TYPE_KEY = "stream-type";
var STREAM_TYPE = /* @__PURE__ */ ((STREAM_TYPE2) => {
  STREAM_TYPE2["REQUEST"] = "REQUEST";
  STREAM_TYPE2["RESPONSE"] = "RESPONSE";
  return STREAM_TYPE2;
})(STREAM_TYPE || {});
function duplex(handler) {
  const pmap = /* @__PURE__ */ new Map();
  const qmap = /* @__PURE__ */ new Map();
  Object.assign(duplexStream, { pmap, qmap });
  async function duplexStream(request, context = /* @__PURE__ */ Object.create(null)) {
    const id = request.headers.get(STREAM_ID_KEY);
    const streamType = request.headers.get(
      STREAM_TYPE_KEY
    );
    const isHalfDuplex = !!id && !!streamType && ![METHOD.GET, METHOD.HEAD].includes(request.method);
    if (!isHalfDuplex) {
      console.log("FULLDUPLEx SUPPORTEd");
      return handler(request, context);
    }
    if (id && !pmap.has(id)) {
      pmap.set(id, new Promised());
      qmap.set(id, new Promised());
    }
    if (streamType === "REQUEST" /* REQUEST */) {
      const getResponse = pmap.get(id);
      const putResponse = qmap.get(id);
      getResponse.resolve(await handler(request, context));
      return putResponse;
    }
    if (streamType === "RESPONSE" /* RESPONSE */) {
      return pmap.get(id);
    }
    return new Response(null, { status: 400 });
  }
  __name(duplexStream, "duplexStream");
  return duplexStream;
}
__name(duplex, "duplex");
export {
  STREAM_ID_KEY,
  STREAM_TYPE,
  STREAM_TYPE_KEY,
  duplex
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vdHJhbnNwb3J0L2hhbmRsZS50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHR5cGUge1xuICBDb250ZXh0LFxuICBSZXF1ZXN0LFxuICBSZXF1ZXN0SGFuZGxlcixcbiAgU2VydmVIYW5kbGVyUmV0dXJuLFxufSBmcm9tIFwiLi90eXBlcy50c1wiO1xuaW1wb3J0IHsgUHJvbWlzZWQgfSBmcm9tIFwiLi4vdXRpbHMvUHJvbWlzZWQudHNcIjtcbmltcG9ydCB7IE1FVEhPRCB9IGZyb20gXCIuL1JvdXRlc0luaXQudHNcIjtcblxuZXhwb3J0IGNvbnN0IFNUUkVBTV9JRF9LRVkgPSBcInN0cmVhbS1pZFwiO1xuZXhwb3J0IGNvbnN0IFNUUkVBTV9UWVBFX0tFWSA9IFwic3RyZWFtLXR5cGVcIjtcbmV4cG9ydCBlbnVtIFNUUkVBTV9UWVBFIHtcbiAgUkVRVUVTVCA9IFwiUkVRVUVTVFwiLFxuICBSRVNQT05TRSA9IFwiUkVTUE9OU0VcIixcbn1cbnR5cGUgUHJvbWlzZWRSZXNwb25zZSA9IFByb21pc2VkPFJlc3BvbnNlIHwgdW5kZWZpbmVkPjtcblxuZXhwb3J0IGZ1bmN0aW9uIGR1cGxleChcbiAgaGFuZGxlcjogUmVxdWVzdEhhbmRsZXIsXG4pIHtcbiAgLy8gcmVxdWVzdHMgbWFwXG4gIGNvbnN0IHBtYXAgPSBuZXcgTWFwPHN0cmluZywgUHJvbWlzZWRSZXNwb25zZT4oKTtcbiAgY29uc3QgcW1hcCA9IG5ldyBNYXA8c3RyaW5nLCBQcm9taXNlZFJlc3BvbnNlPigpO1xuXG4gIE9iamVjdC5hc3NpZ24oZHVwbGV4U3RyZWFtLCB7IHBtYXAsIHFtYXAgfSk7XG5cbiAgYXN5bmMgZnVuY3Rpb24gZHVwbGV4U3RyZWFtPFIgZXh0ZW5kcyBSZXF1ZXN0LCBDIGV4dGVuZHMgQ29udGV4dD4oXG4gICAgcmVxdWVzdDogUixcbiAgICBjb250ZXh0OiBDID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgKTogUHJvbWlzZTxTZXJ2ZUhhbmRsZXJSZXR1cm4+IHtcbiAgICBjb25zdCBpZCA9IHJlcXVlc3QuaGVhZGVycy5nZXQoU1RSRUFNX0lEX0tFWSk7XG4gICAgY29uc3Qgc3RyZWFtVHlwZSA9IHJlcXVlc3QuaGVhZGVycy5nZXQoXG4gICAgICBTVFJFQU1fVFlQRV9LRVksXG4gICAgKSBhcyB1bmtub3duIGFzIFNUUkVBTV9UWVBFO1xuXG4gICAgY29uc3QgaXNIYWxmRHVwbGV4ID0gISFpZCAmJiAhIXN0cmVhbVR5cGUgJiZcbiAgICAgICFbTUVUSE9ELkdFVCwgTUVUSE9ELkhFQURdLmluY2x1ZGVzKHJlcXVlc3QubWV0aG9kIGFzIE1FVEhPRCk7XG5cbiAgICBpZiAoIWlzSGFsZkR1cGxleCkge1xuICAgICAgY29uc29sZS5sb2coXCJGVUxMRFVQTEV4IFNVUFBPUlRFZFwiKTtcbiAgICAgIHJldHVybiBoYW5kbGVyKHJlcXVlc3QsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChpZCAmJiAhcG1hcC5oYXMoaWQpKSB7XG4gICAgICBwbWFwLnNldChpZCwgbmV3IFByb21pc2VkKCkpO1xuICAgICAgcW1hcC5zZXQoaWQsIG5ldyBQcm9taXNlZCgpKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyZWFtVHlwZSA9PT0gU1RSRUFNX1RZUEUuUkVRVUVTVCkge1xuICAgICAgLy8gUmVxdWVzdC5ib2R5IHN0cmVhbVxuXG4gICAgICBjb25zdCBnZXRSZXNwb25zZSA9IHBtYXAuZ2V0KGlkKSE7XG4gICAgICBjb25zdCBwdXRSZXNwb25zZSA9IHFtYXAuZ2V0KGlkKSE7XG5cbiAgICAgIC8vIGNhbGwgaGFuZGxlciB3aXRoIHBvc3QgcmVxdWVzdCBhcmdcbiAgICAgIC8vIHJlc29sdmUgZ2V0IHJlcXVlc3Qgd2l0aCByZXR1cm4gcmVzcG9uc2VcbiAgICAgIGdldFJlc3BvbnNlLnJlc29sdmUoYXdhaXQgaGFuZGxlcihyZXF1ZXN0LCBjb250ZXh0KSk7XG5cbiAgICAgIHJldHVybiBwdXRSZXNwb25zZTtcbiAgICB9XG5cbiAgICBpZiAoc3RyZWFtVHlwZSA9PT0gU1RSRUFNX1RZUEUuUkVTUE9OU0UpIHtcbiAgICAgIC8vIGhhbGYgZHVsZXggLSBnZXRcbiAgICAgIHJldHVybiBwbWFwLmdldChpZCk7IC8vIGFzIFByb21pc2U8UmVzcG9uc2U+O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgfVxuXG4gIHJldHVybiBkdXBsZXhTdHJlYW07XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOztBQU1BLFNBQVMsZ0JBQWdCO0FBQ3pCLFNBQVMsY0FBYztBQUVoQixNQUFNLGdCQUFnQjtBQUN0QixNQUFNLGtCQUFrQjtBQUN4QixJQUFLLGNBQUwsa0JBQUtBLGlCQUFMO0FBQ0wsRUFBQUEsYUFBQSxhQUFVO0FBQ1YsRUFBQUEsYUFBQSxjQUFXO0FBRkQsU0FBQUE7QUFBQSxHQUFBO0FBTUwsU0FBUyxPQUNkLFNBQ0E7QUFFQSxRQUFNLE9BQU8sb0JBQUksSUFBOEI7QUFDL0MsUUFBTSxPQUFPLG9CQUFJLElBQThCO0FBRS9DLFNBQU8sT0FBTyxjQUFjLEVBQUUsTUFBTSxLQUFLLENBQUM7QUFFMUMsaUJBQWUsYUFDYixTQUNBLFVBQWEsdUJBQU8sT0FBTyxJQUFJLEdBQ0Y7QUFDN0IsVUFBTSxLQUFLLFFBQVEsUUFBUSxJQUFJLGFBQWE7QUFDNUMsVUFBTSxhQUFhLFFBQVEsUUFBUTtBQUFBLE1BQ2pDO0FBQUEsSUFDRjtBQUVBLFVBQU0sZUFBZSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsY0FDN0IsQ0FBQyxDQUFDLE9BQU8sS0FBSyxPQUFPLElBQUksRUFBRSxTQUFTLFFBQVEsTUFBZ0I7QUFFOUQsUUFBSSxDQUFDLGNBQWM7QUFDakIsY0FBUSxJQUFJLHNCQUFzQjtBQUNsQyxhQUFPLFFBQVEsU0FBUyxPQUFPO0FBQUEsSUFDakM7QUFFQSxRQUFJLE1BQU0sQ0FBQyxLQUFLLElBQUksRUFBRSxHQUFHO0FBQ3ZCLFdBQUssSUFBSSxJQUFJLElBQUksU0FBUyxDQUFDO0FBQzNCLFdBQUssSUFBSSxJQUFJLElBQUksU0FBUyxDQUFDO0FBQUEsSUFDN0I7QUFFQSxRQUFJLGVBQWUseUJBQXFCO0FBR3RDLFlBQU0sY0FBYyxLQUFLLElBQUksRUFBRTtBQUMvQixZQUFNLGNBQWMsS0FBSyxJQUFJLEVBQUU7QUFJL0Isa0JBQVksUUFBUSxNQUFNLFFBQVEsU0FBUyxPQUFPLENBQUM7QUFFbkQsYUFBTztBQUFBLElBQ1Q7QUFFQSxRQUFJLGVBQWUsMkJBQXNCO0FBRXZDLGFBQU8sS0FBSyxJQUFJLEVBQUU7QUFBQSxJQUNwQjtBQUVBLFdBQU8sSUFBSSxTQUFTLE1BQU0sRUFBRSxRQUFRLElBQUksQ0FBQztBQUFBLEVBQzNDO0FBekNlO0FBMkNmLFNBQU87QUFDVDtBQXJEZ0I7IiwKICAibmFtZXMiOiBbIlNUUkVBTV9UWVBFIl0KfQo=
