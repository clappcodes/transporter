{
  "version": 3,
  "sources": ["../readable/from-body.ts", "../readable/from-url.ts", "../readable/external.ts", "../readable/from-event.ts", "../transform/map.ts", "../colors.ts", "../utils.ts", "../transform/pipe.ts", "../transform/text.ts", "../transform/log.ts", "../writeable/post.ts", "../writeable/subscribe.ts", "../playground.ts"],
  "sourcesContent": ["/**\n * Retrieves the body of a request or response as a ReadableStream.\n * If the body is already a ReadableStream, it is returned as is.\n * Otherwise, a TypeError is thrown.\n *\n * @param input - The request or response object.\n * @returns The body as a ReadableStream.\n * @throws {TypeError} If the body is not a ReadableStream.\n */\nexport function fromBody(\n  input: Request | Response,\n): ReadableStream<Uint8Array> {\n  if (input.body instanceof ReadableStream) {\n    return input.body;\n  }\n\n  throw new TypeError(`Invalid body type: ${typeof input.body}`);\n}\n", "import { fromBody } from \"./from-body.ts\";\n\nexport async function fromURL(\n  input: URL | RequestInfo,\n  init?: RequestInit,\n): Promise<ReadableStream<Uint8Array>> {\n  const request = new Request(input, init);\n  const response = await fetch(request);\n\n  return fromBody(response);\n}\n", "/**\n * Symbol indicating the end of a stream. Used with `external`.\n */\n// @ts-ignore ?\nexport const EOF: symbol = Symbol();\nexport type NextFunc<T> = (v: T | typeof EOF) => void;\n\n/**\n * Utility function to create new observables from external sources.\n * Returns an object with two values: the new observable, and a `next` function\n * which will emit a value to `observable` when called.\n * Calling `next` with `EOF` will indicate there are no more values to emit.\n *\n * @typeparam T Type of items to be emitted by the observable.\n */\nexport function external<T>(): {\n  observable: ReadableStream<T>;\n  next: NextFunc<T>;\n} {\n  let next: NextFunc<T>;\n  const observable = new ReadableStream<T>(\n    {\n      start(controller) {\n        next = (v: T | typeof EOF) => {\n          if (v === EOF) {\n            return controller.close();\n          }\n          controller.enqueue(v as T);\n        };\n      },\n    },\n    { highWaterMark: 0 },\n  );\n  return { observable, next: next! };\n}\n", "import type { Readable } from \"../types.ts\";\n\n/**\n * Creates an observable from an `EventTarget`.\n * Each event is turned into an item for the observable.\n *\n * @typeparam K Type of the event target `el`.\n * @typeparam T Type of the events to be emitted, such as `MouseEvent`.\n * @param el Event target to create an observable from.\n * @param name Name of the event to listen to, such as `'click'`.\n * @returns New observable that emits values from the event target.\n */\nexport function fromEvent<K extends HTMLElement, T extends Event = Event>(\n  el: K,\n  name: string,\n  options?: boolean | AddEventListenerOptions,\n): Readable<T> {\n  let listener: EventListener;\n  return new ReadableStream<T>(\n    {\n      start(controller) {\n        listener = (e) => controller.enqueue(e as T);\n        el.addEventListener(name, listener, options);\n      },\n      cancel() {\n        el.removeEventListener(name, listener, options);\n      },\n    },\n    { highWaterMark: 0 },\n  );\n}\n", "import type { Transform } from \"../types.ts\";\n\n/**\n * Returns a `Transform` with the results of applying the given function\n * to each emitted item of the original observable.\n *\n * @typeparam S Type of items emitted by the original observable.\n * @typeparam T Type of items returned by `f`.\n * @param f Function called with each emitted item. If it returns a promise,\n * the result is awaited then emitted.\n * @returns Transform that emits items produced by `f`.\n */\nexport function map<S, T>(f: (x: S) => T | Promise<T>): Transform<S, T> {\n  return new TransformStream<S, T>(\n    {\n      async transform(chunk, controller) {\n        controller.enqueue(await f(chunk));\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n// A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors\n// on npm.\n\n/**\n * String formatters and utilities for dealing with ANSI color codes.\n *\n * This module is browser compatible.\n *\n * This module supports `NO_COLOR` environmental variable disabling any coloring\n * if `NO_COLOR` is set.\n *\n * @example\n * ```ts\n * import {\n *   bgBlue,\n *   bgRgb24,\n *   bgRgb8,\n *   bold,\n *   italic,\n *   red,\n *   rgb24,\n *   rgb8,\n * } from \"@std/fmt/colors\";\n *\n * console.log(bgBlue(italic(red(bold(\"Hello, World!\")))));\n *\n * // also supports 8bit colors\n *\n * console.log(rgb8(\"Hello, World!\", 42));\n *\n * console.log(bgRgb8(\"Hello, World!\", 42));\n *\n * // and 24bit rgb\n *\n * console.log(rgb24(\"Hello, World!\", {\n *   r: 41,\n *   g: 42,\n *   b: 43,\n * }));\n *\n * console.log(bgRgb24(\"Hello, World!\", {\n *   r: 41,\n *   g: 42,\n *   b: 43,\n * }));\n * ```\n *\n * @module\n */\n\n// deno-lint-ignore no-explicit-any\nconst { Deno } = globalThis as any;\nconst noColor = typeof Deno?.noColor === \"boolean\"\n  ? Deno.noColor as boolean\n  : false;\n\ninterface Code {\n  open: string;\n  close: string;\n  regexp: RegExp;\n}\n\n/** RGB 8-bits per channel. Each in range `0->255` or `0x00->0xff` */\nexport interface Rgb {\n  /** Red component value */\n  r: number;\n  /** Green component value */\n  g: number;\n  /** Blue component value */\n  b: number;\n}\n\nlet enabled = !noColor;\n\n/**\n * Set changing text color to enabled or disabled\n * @param value\n */\nexport function setColorEnabled(value: boolean) {\n  if (Deno?.noColor) {\n    return;\n  }\n\n  enabled = value;\n}\n\n/** Get whether text color change is enabled or disabled. */\nexport function getColorEnabled(): boolean {\n  return enabled;\n}\n\n/**\n * Builds color code\n * @param open\n * @param close\n */\nfunction code(open: number[], close: number): Code {\n  return {\n    open: `\\x1b[${open.join(\";\")}m`,\n    close: `\\x1b[${close}m`,\n    regexp: new RegExp(`\\\\x1b\\\\[${close}m`, \"g\"),\n  };\n}\n\n/**\n * Applies color and background based on color code and its associated text\n * @param str text to apply color settings to\n * @param code color code to apply\n */\nfunction run(str: string, code: Code): string {\n  return enabled\n    ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`\n    : str;\n}\n\n/**\n * Reset the text modified.\n * @param str text to reset\n */\nexport function reset(str: string): string {\n  return run(str, code([0], 0));\n}\n\n/**\n * Make the text bold.\n * @param str text to make bold\n */\nexport function bold(str: string): string {\n  return run(str, code([1], 22));\n}\n\n/**\n * The text emits only a small amount of light.\n * @param str text to dim\n *\n * Warning: Not all terminal emulators support `dim`.\n * For compatibility across all terminals, use {@linkcode gray} or {@linkcode brightBlack} instead.\n */\nexport function dim(str: string): string {\n  return run(str, code([2], 22));\n}\n\n/**\n * Make the text italic.\n * @param str text to make italic\n */\nexport function italic(str: string): string {\n  return run(str, code([3], 23));\n}\n\n/**\n * Make the text underline.\n * @param str text to underline\n */\nexport function underline(str: string): string {\n  return run(str, code([4], 24));\n}\n\n/**\n * Invert background color and text color.\n * @param str text to invert its color\n */\nexport function inverse(str: string): string {\n  return run(str, code([7], 27));\n}\n\n/**\n * Make the text hidden.\n * @param str text to hide\n */\nexport function hidden(str: string): string {\n  return run(str, code([8], 28));\n}\n\n/**\n * Put horizontal line through the center of the text.\n * @param str text to strike through\n */\nexport function strikethrough(str: string): string {\n  return run(str, code([9], 29));\n}\n\n/**\n * Set text color to black.\n * @param str text to make black\n */\nexport function black(str: string): string {\n  return run(str, code([30], 39));\n}\n\n/**\n * Set text color to red.\n * @param str text to make red\n */\nexport function red(str: string): string {\n  return run(str, code([31], 39));\n}\n\n/**\n * Set text color to green.\n * @param str text to make green\n */\nexport function green(str: string): string {\n  return run(str, code([32], 39));\n}\n\n/**\n * Set text color to yellow.\n * @param str text to make yellow\n */\nexport function yellow(str: string): string {\n  return run(str, code([33], 39));\n}\n\n/**\n * Set text color to blue.\n * @param str text to make blue\n */\nexport function blue(str: string): string {\n  return run(str, code([34], 39));\n}\n\n/**\n * Set text color to magenta.\n * @param str text to make magenta\n */\nexport function magenta(str: string): string {\n  return run(str, code([35], 39));\n}\n\n/**\n * Set text color to cyan.\n * @param str text to make cyan\n */\nexport function cyan(str: string): string {\n  return run(str, code([36], 39));\n}\n\n/**\n * Set text color to white.\n * @param str text to make white\n */\nexport function white(str: string): string {\n  return run(str, code([37], 39));\n}\n\n/**\n * Set text color to gray.\n * @param str text to make gray\n */\nexport function gray(str: string): string {\n  return brightBlack(str);\n}\n\n/**\n * Set text color to bright black.\n * @param str text to make bright-black\n */\nexport function brightBlack(str: string): string {\n  return run(str, code([90], 39));\n}\n\n/**\n * Set text color to bright red.\n * @param str text to make bright-red\n */\nexport function brightRed(str: string): string {\n  return run(str, code([91], 39));\n}\n\n/**\n * Set text color to bright green.\n * @param str text to make bright-green\n */\nexport function brightGreen(str: string): string {\n  return run(str, code([92], 39));\n}\n\n/**\n * Set text color to bright yellow.\n * @param str text to make bright-yellow\n */\nexport function brightYellow(str: string): string {\n  return run(str, code([93], 39));\n}\n\n/**\n * Set text color to bright blue.\n * @param str text to make bright-blue\n */\nexport function brightBlue(str: string): string {\n  return run(str, code([94], 39));\n}\n\n/**\n * Set text color to bright magenta.\n * @param str text to make bright-magenta\n */\nexport function brightMagenta(str: string): string {\n  return run(str, code([95], 39));\n}\n\n/**\n * Set text color to bright cyan.\n * @param str text to make bright-cyan\n */\nexport function brightCyan(str: string): string {\n  return run(str, code([96], 39));\n}\n\n/**\n * Set text color to bright white.\n * @param str text to make bright-white\n */\nexport function brightWhite(str: string): string {\n  return run(str, code([97], 39));\n}\n\n/**\n * Set background color to black.\n * @param str text to make its background black\n */\nexport function bgBlack(str: string): string {\n  return run(str, code([40], 49));\n}\n\n/**\n * Set background color to red.\n * @param str text to make its background red\n */\nexport function bgRed(str: string): string {\n  return run(str, code([41], 49));\n}\n\n/**\n * Set background color to green.\n * @param str text to make its background green\n */\nexport function bgGreen(str: string): string {\n  return run(str, code([42], 49));\n}\n\n/**\n * Set background color to yellow.\n * @param str text to make its background yellow\n */\nexport function bgYellow(str: string): string {\n  return run(str, code([43], 49));\n}\n\n/**\n * Set background color to blue.\n * @param str text to make its background blue\n */\nexport function bgBlue(str: string): string {\n  return run(str, code([44], 49));\n}\n\n/**\n *  Set background color to magenta.\n * @param str text to make its background magenta\n */\nexport function bgMagenta(str: string): string {\n  return run(str, code([45], 49));\n}\n\n/**\n * Set background color to cyan.\n * @param str text to make its background cyan\n */\nexport function bgCyan(str: string): string {\n  return run(str, code([46], 49));\n}\n\n/**\n * Set background color to white.\n * @param str text to make its background white\n */\nexport function bgWhite(str: string): string {\n  return run(str, code([47], 49));\n}\n\n/**\n * Set background color to bright black.\n * @param str text to make its background bright-black\n */\nexport function bgBrightBlack(str: string): string {\n  return run(str, code([100], 49));\n}\n\n/**\n * Set background color to bright red.\n * @param str text to make its background bright-red\n */\nexport function bgBrightRed(str: string): string {\n  return run(str, code([101], 49));\n}\n\n/**\n * Set background color to bright green.\n * @param str text to make its background bright-green\n */\nexport function bgBrightGreen(str: string): string {\n  return run(str, code([102], 49));\n}\n\n/**\n * Set background color to bright yellow.\n * @param str text to make its background bright-yellow\n */\nexport function bgBrightYellow(str: string): string {\n  return run(str, code([103], 49));\n}\n\n/**\n * Set background color to bright blue.\n * @param str text to make its background bright-blue\n */\nexport function bgBrightBlue(str: string): string {\n  return run(str, code([104], 49));\n}\n\n/**\n * Set background color to bright magenta.\n * @param str text to make its background bright-magenta\n */\nexport function bgBrightMagenta(str: string): string {\n  return run(str, code([105], 49));\n}\n\n/**\n * Set background color to bright cyan.\n * @param str text to make its background bright-cyan\n */\nexport function bgBrightCyan(str: string): string {\n  return run(str, code([106], 49));\n}\n\n/**\n * Set background color to bright white.\n * @param str text to make its background bright-white\n */\nexport function bgBrightWhite(str: string): string {\n  return run(str, code([107], 49));\n}\n\n/* Special Color Sequences */\n\n/**\n * Clam and truncate color codes\n * @param n\n * @param max number to truncate to\n * @param min number to truncate from\n */\nfunction clampAndTruncate(n: number, max = 255, min = 0): number {\n  return Math.trunc(Math.max(Math.min(n, max), min));\n}\n\n/**\n * Set text color using paletted 8bit colors.\n * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit\n * @param str text color to apply paletted 8bit colors to\n * @param color code\n */\nexport function rgb8(str: string, color: number): string {\n  return run(str, code([38, 5, clampAndTruncate(color)], 39));\n}\n\n/**\n * Set background color using paletted 8bit colors.\n * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit\n * @param str text color to apply paletted 8bit background colors to\n * @param color code\n */\nexport function bgRgb8(str: string, color: number): string {\n  return run(str, code([48, 5, clampAndTruncate(color)], 49));\n}\n\n/**\n * Set text color using 24bit rgb.\n * `color` can be a number in range `0x000000` to `0xffffff` or\n * an `Rgb`.\n *\n * To produce the color magenta:\n *\n * ```ts\n * import { rgb24 } from \"@std/fmt/colors\";\n *\n * rgb24(\"foo\", 0xff00ff);\n * rgb24(\"foo\", {r: 255, g: 0, b: 255});\n * ```\n * @param str text color to apply 24bit rgb to\n * @param color code\n */\nexport function rgb24(str: string, color: number | Rgb): string {\n  if (typeof color === \"number\") {\n    return run(\n      str,\n      code(\n        [38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff],\n        39,\n      ),\n    );\n  }\n  return run(\n    str,\n    code(\n      [\n        38,\n        2,\n        clampAndTruncate(color.r),\n        clampAndTruncate(color.g),\n        clampAndTruncate(color.b),\n      ],\n      39,\n    ),\n  );\n}\n\n/**\n * Set background color using 24bit rgb.\n * `color` can be a number in range `0x000000` to `0xffffff` or\n * an `Rgb`.\n *\n * To produce the color magenta:\n *\n * ```ts\n * import { bgRgb24 } from \"@std/fmt/colors\";\n *\n * bgRgb24(\"foo\", 0xff00ff);\n * bgRgb24(\"foo\", {r: 255, g: 0, b: 255});\n * ```\n * @param str text color to apply 24bit rgb to\n * @param color code\n */\nexport function bgRgb24(str: string, color: number | Rgb): string {\n  if (typeof color === \"number\") {\n    return run(\n      str,\n      code(\n        [48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff],\n        49,\n      ),\n    );\n  }\n  return run(\n    str,\n    code(\n      [\n        48,\n        2,\n        clampAndTruncate(color.r),\n        clampAndTruncate(color.g),\n        clampAndTruncate(color.b),\n      ],\n      49,\n    ),\n  );\n}\n\n// https://github.com/chalk/ansi-regex/blob/02fa893d619d3da85411acc8fd4e2eea0e95a9d9/index.js\nconst ANSI_PATTERN = new RegExp(\n  [\n    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TXZcf-nq-uy=><~]))\",\n  ].join(\"|\"),\n  \"g\",\n);\n\n/**\n * Remove ANSI escape codes from the string.\n * @param string to remove ANSI escape codes from\n *\n *  @deprecated (will be removed in 1.0.0) Use {@linkcode stripAnsiCode} instead.\n */\nexport function stripColor(string: string): string {\n  return stripAnsiCode(string);\n}\n\n/**\n * Remove ANSI escape codes from the string.\n *\n * @param string to remove ANSI escape codes from\n */\nexport function stripAnsiCode(string: string): string {\n  return string.replace(ANSI_PATTERN, \"\");\n}\n", "// deno-lint-ignore-file\nimport * as colors from \"./colors.ts\";\nimport { type OutgoingStream } from \"./OutgoingStream.ts\";\nimport { type IncomingStream } from \"./IncomingStream.ts\";\n\nexport { colors };\n\n// export const DEBUG: boolean = typeof Deno !== \"undefined\"\n//   ? Boolean(Deno.env.get(\"DEBUG\"))\n//   : Reflect.get(globalThis, \"DEBUG\");\n\nexport const isDebug = (): boolean =>\n  typeof Deno !== \"undefined\"\n    ? Deno.env.get(\"DEBUG\") === \"true\"\n    : Boolean(Reflect.get(globalThis, \"DEBUG\"));\n\nObject.assign(globalThis, { isDebug });\n\nconsole.log(\n  colors.green(\"(utils) DEBUG\") + \"=\" +\n    colors.white(isDebug() + \"\"),\n);\n\nexport function duplexFetch(\n  input: string | URL | Request,\n  init?: RequestInit,\n): Promise<Response> {\n  const id = String(Math.random());\n\n  const { body, ...rest } = init || {};\n\n  const headers = {\n    [idKey]: id,\n    ...init?.headers,\n  };\n\n  fetch(input, {\n    body,\n    // @ts-ignore .\n    duplex: \"half\",\n    method: \"POST\",\n    headers,\n    ...rest,\n  }).then(async (response) => {\n    console.log(\"POST Request(\" + id + \")\", \"Done\", await response.text());\n  });\n\n  return fetch(input, { headers, ...rest });\n}\n\nexport async function delay(ms: number): Promise<unknown> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\nexport const idKey = \"transporter-stream-id\";\nexport enum ReadyState {\n  CONNECTING = 0,\n  INCOMING = 1,\n  OUTGOING = 2,\n  OPEN = 3,\n  CLOSED = 4,\n  ERRORED = 5,\n}\n\nexport function* mkRangeIterator(\n  start = 0,\n  end = Infinity,\n  step = 1,\n): Generator<number, number, unknown> {\n  let iterationCount = 0;\n  for (let i = start; i < end; i += step) {\n    iterationCount++;\n    yield i;\n  }\n  return iterationCount;\n}\n\nexport async function* mkRangeAsyncIterator(\n  start = 0,\n  end = Infinity,\n  delay = 100,\n): AsyncGenerator<unknown, number, unknown> {\n  let iterationCount = 0;\n  for (let i = start; i < end; i += 1) {\n    iterationCount++;\n    yield await new Promise((resolve) => {\n      setTimeout(() => resolve(i), delay);\n    });\n  }\n  return iterationCount;\n}\n\nexport class DeferredPromise<T> extends Promise<T> {\n  declare resolve: (value: T) => void;\n  declare reject: (reason?: unknown) => void;\n\n  constructor(\n    resolver?: (\n      resolve: (value: T) => void,\n      reject: (reason?: unknown) => void,\n    ) => void,\n  ) {\n    const that = {};\n    super(function (resolve, reject) {\n      Object.assign(that, { resolve, reject });\n    });\n    Object.assign(this, that);\n    if (resolver) {\n      resolver(this.resolve, this.reject);\n    }\n  }\n}\n\nexport function log(\n  _this: IncomingStream | OutgoingStream,\n  method: string,\n  ...value: unknown[]\n) {\n  if (!isDebug()) return;\n  const isIn = _this.constructor.name === \"IncomingStream\";\n  const nameColor = isIn ? colors.cyan : colors.magenta;\n  const nameBg = (a: string) => a;\n\n  console.log(\n    colors.gray(\n      `${(nameColor(\n        nameBg(\n          colors.bold(_this.name) + \"[\" + _this.env + \"]\" + \" /\" +\n            colors.italic(_this.url.pathname) +\n            \" \",\n        ),\n      ))} ${colors.brightWhite(colors.bold(method))}(${\n        colors.brightYellow(_this.id) + \", \" +\n        colors.brightGreen(_this.idx + \"\")\n      }) ${colors.blue(\"=>\")}`,\n    ),\n    ...value,\n  );\n}\n\nexport async function getStream(\n  url: URL | string,\n  transform: TransformStream = new TextDecoderStream(),\n): Promise<{\n  url: URL;\n  id: number;\n  request: Request;\n  response: Response;\n  readable: ReadableStream<string>;\n}> {\n  url = new URL(url, location.href);\n\n  const abortController = new AbortController();\n  const headers = new Headers();\n\n  const request = new Request(url, {\n    method: \"GET\",\n    cache: \"no-cache\",\n    // @ts-ignore ?\n    signal: abortController.signal,\n    headers,\n  });\n\n  const response = await fetch(request);\n  const id = Number(response.headers.get(\"duplex-id\") || \"0\");\n  url.hash = `#${id}`;\n\n  if (!response.body) {\n    throw new Error(`Response body`);\n  }\n\n  const readable = response.body.pipeThrough(transform);\n\n  return {\n    url,\n    id,\n    request,\n    response,\n    readable,\n  };\n}\n\nexport function putStream(\n  url: URL | string,\n  transform: TransformStream = new TextEncoderStream(),\n): {\n  id: number;\n  writable: WritableStream<any>;\n  readable: ReadableStream<any>;\n  readable1: ReadableStream<any>;\n  readable2: ReadableStream<any>;\n  headers: Headers;\n  request: Request;\n  response: Promise<Response>;\n  abortController: AbortController;\n} {\n  url = new URL(url, location.href);\n\n  const { writable, readable } = transform;\n  const [readable1, readable2] = readable.tee();\n  const abortController = new AbortController();\n\n  const headers = new Headers();\n  const id = Number(url.hash.slice(1) || \"0\");\n\n  if (id) {\n    headers.set(\"duplex-id\", String(id));\n  }\n\n  const request = new Request(url, {\n    method: \"PUT\",\n    body: readable1,\n    cache: \"no-cache\",\n    // @ts-ignore ?\n    duplex: \"half\",\n    signal: abortController.signal,\n    headers,\n  });\n\n  const response = fetch(request);\n\n  response.then(async (response) => {\n    if (response.ok) {\n      const message = await response.text();\n\n      console.log(\"[closed]\", message);\n      return;\n    }\n\n    const status = response.status;\n    const message = await response.text();\n\n    throw new Error(`Request failed: ${message}`, { cause: status });\n  }).catch((error: Error) => {\n    console.warn(error.name, error.cause, error.message);\n  });\n\n  const o = {\n    id,\n    writable,\n    readable,\n    readable1,\n    readable2,\n    headers,\n    request,\n    response,\n    abortController,\n  };\n\n  return o;\n}\n\nexport function createRead<T>(\n  readable: ReadableStream<T> | { readable: ReadableStream<T> },\n  cb: (chunk: T) => void,\n): Promise<void> {\n  const reader = (readable instanceof ReadableStream)\n    ? readable.getReader()\n    : readable.readable.getReader();\n\n  async function read(cb: (chunk: T) => void) {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          return;\n        }\n        cb(value);\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  }\n\n  return read(cb);\n}\n\nexport function createWrite<T>(\n  writable: WritableStream<T> | { writable: WritableStream<T> },\n): (chunk: T) => Promise<void> {\n  const writer = (writable instanceof WritableStream)\n    ? writable.getWriter()\n    : writable.writable.getWriter();\n\n  Object.assign(write, { writer });\n\n  async function write(chunk: T) {\n    await writer.ready;\n    await writer.write(chunk);\n  }\n\n  return write;\n}\n\nexport const swapObject = <T extends { [key: PropertyKey]: any }>(\n  obj: T,\n): {\n  [K in keyof T as T[K]]: K;\n} => Object.fromEntries(Object.entries(obj).map(([k, v]) => [v, k]));\n\nexport const valueFromKeyObject = <T extends { [key: PropertyKey]: any }>(\n  obj: T,\n): {\n  [K in keyof T]: K;\n} => Object.fromEntries(Object.entries(obj).map(([k, _v]) => [k as any, k]));\n\nexport const _isTransformStream = <T extends object>(input: T): boolean =>\n  typeof input === \"object\" &&\n  Object.hasOwn(input, \"writable\") && Object.hasOwn(input, \"readable\");\n\nexport const isTransformStream = (a: unknown): a is GenericTransformStream =>\n  typeof a === \"object\" && \"readable\" in a!;\n\ntype LengthOfTuple<T extends any[]> = T extends { length: infer L } ? L\n  : never;\ntype DropFirstInTuple<T extends any[]> = ((...args: T) => any) extends\n  (arg: any, ...rest: infer U) => any ? U : T;\nexport type LastInTuple<T extends any[]> =\n  T[LengthOfTuple<DropFirstInTuple<T>>];\n\nexport class PipelineStream<\n  T extends [TransformStream, ...TransformStream[]],\n> {\n  readable: LastInTuple<T>[\"readable\"];\n  writable: T[0][\"writable\"];\n\n  constructor(\n    private transformers: T,\n    writableStrategy?: QueuingStrategy,\n    readableStrategy?: QueuingStrategy,\n  ) {\n    const [first, ...rest] = this.transformers;\n\n    this.writable = first.writable;\n    this.readable = rest.reduce(\n      (readable, transform) => readable.pipeThrough(transform),\n      first.readable,\n    );\n\n    // if (this.transformers.length === 3) {\n    //   this.readable = this.transformers[0].readable\n    //     .pipeThrough(this.transformers[1])\n    //     .pipeThrough(this.transformers[2]);\n    // } else {\n    //   this.readable = this.transformers.at(-1)!.readable;\n    // }\n  }\n}\n\n// const pip = new PipelineStream([\n//   new TransformStream<string, number>(),\n//   new TransformStream<number, symbol>(),\n//   new TransformStream<string, number>(),\n// ]);\n\n// pip.writable.getWriter().write(\"ss\");\n// pip.readable.getReader();\n", "import type {\n  StrictStream,\n  StrictStreamMapper,\n  StrictStreamPlumber,\n} from \"../types.ts\";\nimport { isTransformStream } from \"../utils.ts\";\n\nexport const transform =\n  <I, O>(transform: TransformStream<I, O>) =>\n  (input: ReadableStream<I>): ReadableStream<O> => {\n    return input.pipeThrough(transform);\n  };\n\nexport function pipe<In, Out>(\n  mapper: StrictStreamMapper<In, Out> | TransformStream<In, Out>,\n): StrictStreamPlumber<In, Out> {\n  const streamMapper: StrictStreamMapper<In, Out> = (input: StrictStream<In>) =>\n    isTransformStream(mapper) ? transform(mapper)(input) : mapper(input);\n\n  // todo: make it work\n  if (isTransformStream(mapper)) {\n    Object.defineProperties(streamMapper, {\n      readable: {\n        get: () => mapper.readable,\n        enumerable: true,\n      },\n      writable: {\n        get: () => mapper.writable,\n        enumerable: true,\n      },\n    });\n  }\n\n  // @ts-ignore ?\n  streamMapper.pipe = <Output>(\n    mapper: StrictStreamMapper<Out, Output> | TransformStream<Out, Output>,\n  ) => {\n    return pipe<In, Output>((input: StrictStream<In>) => {\n      const nextStream = streamMapper(input);\n      return isTransformStream(mapper)\n        ? transform(mapper)(nextStream)\n        : mapper(nextStream);\n    });\n  };\n\n  return streamMapper as StrictStreamPlumber<In, Out>;\n}\n", "import type { Transform } from \"../types.ts\";\n\nexport function encode(): TextEncoderStream;\n\nexport function encode(\n  input: ReadableStream<string>,\n): ReadableStream<Uint8Array>;\n\nexport function encode(\n  input?: ReadableStream<string>,\n): ReadableStream<Uint8Array> | Transform<string, Uint8Array> {\n  return input\n    ? input.pipeThrough(new TextEncoderStream())\n    : new TextEncoderStream();\n}\n\nexport function decode(): TextDecoderStream;\n\nexport function decode(\n  input: ReadableStream<Uint8Array>,\n): ReadableStream<string>;\n\nexport function decode(\n  input?: ReadableStream<Uint8Array>,\n): ReadableStream<string> | Transform<Uint8Array, string> {\n  return input\n    ? input.pipeThrough(new TextDecoderStream())\n    : new TextDecoderStream();\n}\n", "import type { Transform } from \"../types.ts\";\n\nexport function log<T>(tag: string = \"\"): Transform<T> {\n  return new TransformStream<T, T>(\n    {\n      start() {\n        console.warn(tag, \"started\");\n      },\n      async transform(chunk, controller) {\n        controller.enqueue(chunk);\n        console.log(tag, await chunk);\n      },\n      async cancel(reason) {\n        await Promise.resolve(console.warn(tag, \"canceled\", reason));\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "export interface RequestStreamInit extends Omit<RequestInit, \"method\"> {\n  body: ReadableStream<Uint8Array>;\n}\n\nexport class RequestStream extends Request {\n  constructor(input: RequestInfo | URL, init?: RequestStreamInit) {\n    const isReadableStream = init?.body instanceof ReadableStream;\n\n    if (!isReadableStream) {\n      throw new TypeError(\"Invalid body: \" + typeof init?.body);\n    }\n\n    super(input, {\n      method: \"POST\",\n      // @ts-ignore .\n      duplex: \"half\",\n      ...init,\n    });\n  }\n}\n\nexport function post<T extends Uint8Array>(\n  input: RequestInfo | URL,\n  init?: RequestStreamInit,\n): WritableStream<T> {\n  const { readable, writable } = new TransformStream<T, T>();\n\n  const request = new RequestStream(input, {\n    ...init,\n    body: readable,\n  });\n\n  fetch(request);\n\n  return writable;\n}\n\nexport function response<T extends Uint8Array>(\n  init?: ResponseInit,\n): { writable: WritableStream<T>; response: Response } {\n  const { readable, writable } = new TransformStream<T, T>();\n\n  const response = new Response(readable, init);\n\n  return { writable, response };\n}\n", "/**\n * Sink for observables that discards all values.\n * Useful to leave at the end of a chain.\n *\n * @typeparam T Type of items emitted by the observable.\n * @param f Function to call for each value before it\u2019s discarded.\n */\nexport function subscribe<T>(f: (v: T) => void = () => {}): WritableStream<T> {\n  return new WritableStream<T>(\n    {\n      write(chunk: T) {\n        f(chunk);\n      },\n    },\n    { highWaterMark: 1 },\n  );\n}\n", "import { fromBody, fromEvent, fromURL } from \"./readable/mod.ts\";\nimport { decode, encode, log, map, pipe } from \"./transform/mod.ts\";\n\nimport { duplexFetch } from \"./utils.ts\";\nimport { post } from \"./writeable/post.ts\";\nimport { subscribe } from \"./writeable/subscribe.ts\";\n\nexport const arr = () =>\n  pipe(decode)\n    .pipe(map((chunk) => chunk.split(\":\")))\n    .pipe(map(([key, val]): [string, number] => [key, Number(val)]));\n\nexport const sse = () =>\n  pipe(decode)\n    .pipe(map((chunk) => chunk.split(\":\")))\n    .pipe(map(([key, val]) => ({ [key]: Number(val) })));\n\nexport async function receive() {\n  const stream = await fromURL(\"/sse\")\n    .then(pipe(decode()).pipe(log(\"foo\")));\n\n  stream.pipeTo(subscribe((val) => {\n    document.querySelector(\"#outgoing\")!.textContent = val;\n  }));\n}\n\nexport function send() {\n  const body = fromEvent<HTMLInputElement, InputEvent>(\n    document.querySelector(\"#message\")!,\n    \"input\",\n  )\n    .pipeThrough(map((e) => e.data))\n    .pipeThrough(encode());\n\n  const [a, b] = body.tee();\n\n  a.pipeThrough(decode()).pipeTo(subscribe(console.warn));\n\n  return b.pipeTo(post(\"/sse\"));\n}\n\nexport const toEvent = <E extends \"message\" | \"ping\" = \"message\">(\n  event: E = \"message\" as E,\n) =>\n  map<string, string>(\n    (data) =>\n      [\n        [\"event\", event || \"message\"].join(\": \"),\n        [\"data\", String(data)].join(\": \"),\n      ].join(\"\\n\") + \"\\n\\n\",\n  );\n\nexport async function echo() {\n  // const body = pipe(toEvent()).pipe(map((val) => delay(1000).then(() => val))).pipe(\n  //   encode(),\n  // )(\n  //   from([\"one\", \"two\", \"22\", \"How atre u\"]),\n  // )\n\n  const incomingStream = await duplexFetch(\"/echo\", {\n    body: fromEvent<HTMLInputElement, InputEvent>(\n      document.querySelector(\"#message\")!,\n      \"input\",\n    )\n      .pipeThrough(map((e) => e.data))\n      .pipeThrough(toEvent(\"message\")) // SSE\n      .pipeThrough(encode()),\n  })\n    .then(fromBody)\n    .then(decode);\n\n  const [domStream, iterStream] = incomingStream.tee();\n\n  domStream.pipeTo(subscribe((val) => {\n    document.querySelector(\"#outgoing\")!.innerHTML = val;\n  }));\n\n  for await (const _chunk of iterStream) {\n    console.log(_chunk);\n  }\n}\n\nexport async function main() {\n  // await receive();\n  // await send();\n\n  await echo();\n}\n"],
  "mappings": "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",
  "names": ["Deno", "code", "transform", "mapper"]
}
