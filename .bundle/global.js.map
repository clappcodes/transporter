{
  "version": 3,
  "sources": ["../colors.ts", "../mod.ts", "../utils/is-plain-object.ts", "../readable/from.ts", "../shims.ts", "../readable/mod.ts", "../readable/from-body.ts", "../readable/from-fetch.ts", "../readable/from-timer.ts", "../readable/external.ts", "../readable/from-event.ts", "../readable/from-iterable.ts", "../readable/from-generator.ts", "../readable/just.ts", "../readable/range.ts", "../readable/read.ts", "../readable/consume.ts", "../writable/mod.ts", "../writable/subscribe.ts", "../writable/write.ts", "../transform/mod.ts", "../transform/each.ts", "../transform/lower-case.ts", "../transform/map.ts", "../utils.ts", "../transform/pipe.ts", "../transform/tap.ts", "../transform/text.ts", "../transform/upper-case.ts", "../transform/log.ts", "../transform/to.ts", "../transform/to-uint8array.ts", "../transform/debounce.ts", "../transform/filter.ts", "../transform/check.ts", "../transform/apply.ts", "../transporter/ess/parser.ts", "../transporter/ess/parse.ts", "../transporter/ess/stringify.ts", "../transporter/ess/EventSourceMessage.ts", "../transporter/ess/EventSourceDecoderStream.ts", "../transporter/ess/EventSourceEncoderStream.ts", "../transform/sse.ts", "../transporter/contstants.ts", "../transporter/utils/is.ts", "../transporter/utils/Promised.ts", "../transporter/duplexHandler.ts", "../transporter/DuplexRequest.ts", "../transporter/TransportStream.ts", "../transporter/TextTransportStream.ts", "../transporter/PairStream.ts", "../transporter/pipe.ts", "../transporter/PipeStream.ts", "../transporter/JSONTransportStream.ts", "../transporter/ess/mod.ts", "../transporter/EventSourceTransportStream.ts", "../transporter/BroadcastStream.ts", "../transporter/Router.ts", "../transporter/utils/mod.ts", "../transporter/utils/pipeTo.ts", "../transporter/utils/path.ts", "../deno.json", "../global.ts"],
  "sourcesContent": ["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n// A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors\n// on npm.\n\n/**\n * String formatters and utilities for dealing with ANSI color codes.\n *\n * This module is browser compatible.\n *\n * This module supports `NO_COLOR` environmental variable disabling any coloring\n * if `NO_COLOR` is set.\n *\n * @example\n * ```ts\n * import {\n *   bgBlue,\n *   bgRgb24,\n *   bgRgb8,\n *   bold,\n *   italic,\n *   red,\n *   rgb24,\n *   rgb8,\n * } from \"@std/fmt/colors\";\n *\n * console.log(bgBlue(italic(red(bold(\"Hello, World!\")))));\n *\n * // also supports 8bit colors\n *\n * console.log(rgb8(\"Hello, World!\", 42));\n *\n * console.log(bgRgb8(\"Hello, World!\", 42));\n *\n * // and 24bit rgb\n *\n * console.log(rgb24(\"Hello, World!\", {\n *   r: 41,\n *   g: 42,\n *   b: 43,\n * }));\n *\n * console.log(bgRgb24(\"Hello, World!\", {\n *   r: 41,\n *   g: 42,\n *   b: 43,\n * }));\n * ```\n *\n * @module\n */\n\n// deno-lint-ignore no-explicit-any\nconst { Deno } = globalThis as any;\nconst noColor = typeof Deno?.noColor === \"boolean\"\n  ? Deno.noColor as boolean\n  : false;\n\ninterface Code {\n  open: string;\n  close: string;\n  regexp: RegExp;\n}\n\n/** RGB 8-bits per channel. Each in range `0->255` or `0x00->0xff` */\nexport interface Rgb {\n  /** Red component value */\n  r: number;\n  /** Green component value */\n  g: number;\n  /** Blue component value */\n  b: number;\n}\n\nlet enabled = !noColor;\n\n/**\n * Set changing text color to enabled or disabled\n * @param value\n */\nexport function setColorEnabled(value: boolean) {\n  if (Deno?.noColor) {\n    return;\n  }\n\n  enabled = value;\n}\n\n/** Get whether text color change is enabled or disabled. */\nexport function getColorEnabled(): boolean {\n  return enabled;\n}\n\n/**\n * Builds color code\n * @param open\n * @param close\n */\nfunction code(open: number[], close: number): Code {\n  return {\n    open: `\\x1b[${open.join(\";\")}m`,\n    close: `\\x1b[${close}m`,\n    regexp: new RegExp(`\\\\x1b\\\\[${close}m`, \"g\"),\n  };\n}\n\n/**\n * Applies color and background based on color code and its associated text\n * @param str text to apply color settings to\n * @param code color code to apply\n */\nfunction run(str: string, code: Code): string {\n  return enabled\n    ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`\n    : str;\n}\n\n/**\n * Reset the text modified.\n * @param str text to reset\n */\nexport function reset(str: string): string {\n  return run(str, code([0], 0));\n}\n\n/**\n * Make the text bold.\n * @param str text to make bold\n */\nexport function bold(str: string): string {\n  return run(str, code([1], 22));\n}\n\n/**\n * The text emits only a small amount of light.\n * @param str text to dim\n *\n * Warning: Not all terminal emulators support `dim`.\n * For compatibility across all terminals, use {@linkcode gray} or {@linkcode brightBlack} instead.\n */\nexport function dim(str: string): string {\n  return run(str, code([2], 22));\n}\n\n/**\n * Make the text italic.\n * @param str text to make italic\n */\nexport function italic(str: string): string {\n  return run(str, code([3], 23));\n}\n\n/**\n * Make the text underline.\n * @param str text to underline\n */\nexport function underline(str: string): string {\n  return run(str, code([4], 24));\n}\n\n/**\n * Invert background color and text color.\n * @param str text to invert its color\n */\nexport function inverse(str: string): string {\n  return run(str, code([7], 27));\n}\n\n/**\n * Make the text hidden.\n * @param str text to hide\n */\nexport function hidden(str: string): string {\n  return run(str, code([8], 28));\n}\n\n/**\n * Put horizontal line through the center of the text.\n * @param str text to strike through\n */\nexport function strikethrough(str: string): string {\n  return run(str, code([9], 29));\n}\n\n/**\n * Set text color to black.\n * @param str text to make black\n */\nexport function black(str: string): string {\n  return run(str, code([30], 39));\n}\n\n/**\n * Set text color to red.\n * @param str text to make red\n */\nexport function red(str: string): string {\n  return run(str, code([31], 39));\n}\n\n/**\n * Set text color to green.\n * @param str text to make green\n */\nexport function green(str: string): string {\n  return run(str, code([32], 39));\n}\n\n/**\n * Set text color to yellow.\n * @param str text to make yellow\n */\nexport function yellow(str: string): string {\n  return run(str, code([33], 39));\n}\n\n/**\n * Set text color to blue.\n * @param str text to make blue\n */\nexport function blue(str: string): string {\n  return run(str, code([34], 39));\n}\n\n/**\n * Set text color to magenta.\n * @param str text to make magenta\n */\nexport function magenta(str: string): string {\n  return run(str, code([35], 39));\n}\n\n/**\n * Set text color to cyan.\n * @param str text to make cyan\n */\nexport function cyan(str: string): string {\n  return run(str, code([36], 39));\n}\n\n/**\n * Set text color to white.\n * @param str text to make white\n */\nexport function white(str: string): string {\n  return run(str, code([37], 39));\n}\n\n/**\n * Set text color to gray.\n * @param str text to make gray\n */\nexport function gray(str: string): string {\n  return brightBlack(str);\n}\n\n/**\n * Set text color to bright black.\n * @param str text to make bright-black\n */\nexport function brightBlack(str: string): string {\n  return run(str, code([90], 39));\n}\n\n/**\n * Set text color to bright red.\n * @param str text to make bright-red\n */\nexport function brightRed(str: string): string {\n  return run(str, code([91], 39));\n}\n\n/**\n * Set text color to bright green.\n * @param str text to make bright-green\n */\nexport function brightGreen(str: string): string {\n  return run(str, code([92], 39));\n}\n\n/**\n * Set text color to bright yellow.\n * @param str text to make bright-yellow\n */\nexport function brightYellow(str: string): string {\n  return run(str, code([93], 39));\n}\n\n/**\n * Set text color to bright blue.\n * @param str text to make bright-blue\n */\nexport function brightBlue(str: string): string {\n  return run(str, code([94], 39));\n}\n\n/**\n * Set text color to bright magenta.\n * @param str text to make bright-magenta\n */\nexport function brightMagenta(str: string): string {\n  return run(str, code([95], 39));\n}\n\n/**\n * Set text color to bright cyan.\n * @param str text to make bright-cyan\n */\nexport function brightCyan(str: string): string {\n  return run(str, code([96], 39));\n}\n\n/**\n * Set text color to bright white.\n * @param str text to make bright-white\n */\nexport function brightWhite(str: string): string {\n  return run(str, code([97], 39));\n}\n\n/**\n * Set background color to black.\n * @param str text to make its background black\n */\nexport function bgBlack(str: string): string {\n  return run(str, code([40], 49));\n}\n\n/**\n * Set background color to red.\n * @param str text to make its background red\n */\nexport function bgRed(str: string): string {\n  return run(str, code([41], 49));\n}\n\n/**\n * Set background color to green.\n * @param str text to make its background green\n */\nexport function bgGreen(str: string): string {\n  return run(str, code([42], 49));\n}\n\n/**\n * Set background color to yellow.\n * @param str text to make its background yellow\n */\nexport function bgYellow(str: string): string {\n  return run(str, code([43], 49));\n}\n\n/**\n * Set background color to blue.\n * @param str text to make its background blue\n */\nexport function bgBlue(str: string): string {\n  return run(str, code([44], 49));\n}\n\n/**\n *  Set background color to magenta.\n * @param str text to make its background magenta\n */\nexport function bgMagenta(str: string): string {\n  return run(str, code([45], 49));\n}\n\n/**\n * Set background color to cyan.\n * @param str text to make its background cyan\n */\nexport function bgCyan(str: string): string {\n  return run(str, code([46], 49));\n}\n\n/**\n * Set background color to white.\n * @param str text to make its background white\n */\nexport function bgWhite(str: string): string {\n  return run(str, code([47], 49));\n}\n\n/**\n * Set background color to bright black.\n * @param str text to make its background bright-black\n */\nexport function bgBrightBlack(str: string): string {\n  return run(str, code([100], 49));\n}\n\n/**\n * Set background color to bright red.\n * @param str text to make its background bright-red\n */\nexport function bgBrightRed(str: string): string {\n  return run(str, code([101], 49));\n}\n\n/**\n * Set background color to bright green.\n * @param str text to make its background bright-green\n */\nexport function bgBrightGreen(str: string): string {\n  return run(str, code([102], 49));\n}\n\n/**\n * Set background color to bright yellow.\n * @param str text to make its background bright-yellow\n */\nexport function bgBrightYellow(str: string): string {\n  return run(str, code([103], 49));\n}\n\n/**\n * Set background color to bright blue.\n * @param str text to make its background bright-blue\n */\nexport function bgBrightBlue(str: string): string {\n  return run(str, code([104], 49));\n}\n\n/**\n * Set background color to bright magenta.\n * @param str text to make its background bright-magenta\n */\nexport function bgBrightMagenta(str: string): string {\n  return run(str, code([105], 49));\n}\n\n/**\n * Set background color to bright cyan.\n * @param str text to make its background bright-cyan\n */\nexport function bgBrightCyan(str: string): string {\n  return run(str, code([106], 49));\n}\n\n/**\n * Set background color to bright white.\n * @param str text to make its background bright-white\n */\nexport function bgBrightWhite(str: string): string {\n  return run(str, code([107], 49));\n}\n\n/* Special Color Sequences */\n\n/**\n * Clam and truncate color codes\n * @param n\n * @param max number to truncate to\n * @param min number to truncate from\n */\nfunction clampAndTruncate(n: number, max = 255, min = 0): number {\n  return Math.trunc(Math.max(Math.min(n, max), min));\n}\n\n/**\n * Set text color using paletted 8bit colors.\n * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit\n * @param str text color to apply paletted 8bit colors to\n * @param color code\n */\nexport function rgb8(str: string, color: number): string {\n  return run(str, code([38, 5, clampAndTruncate(color)], 39));\n}\n\n/**\n * Set background color using paletted 8bit colors.\n * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit\n * @param str text color to apply paletted 8bit background colors to\n * @param color code\n */\nexport function bgRgb8(str: string, color: number): string {\n  return run(str, code([48, 5, clampAndTruncate(color)], 49));\n}\n\n/**\n * Set text color using 24bit rgb.\n * `color` can be a number in range `0x000000` to `0xffffff` or\n * an `Rgb`.\n *\n * To produce the color magenta:\n *\n * ```ts\n * import { rgb24 } from \"@std/fmt/colors\";\n *\n * rgb24(\"foo\", 0xff00ff);\n * rgb24(\"foo\", {r: 255, g: 0, b: 255});\n * ```\n * @param str text color to apply 24bit rgb to\n * @param color code\n */\nexport function rgb24(str: string, color: number | Rgb): string {\n  if (typeof color === \"number\") {\n    return run(\n      str,\n      code(\n        [38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff],\n        39,\n      ),\n    );\n  }\n  return run(\n    str,\n    code(\n      [\n        38,\n        2,\n        clampAndTruncate(color.r),\n        clampAndTruncate(color.g),\n        clampAndTruncate(color.b),\n      ],\n      39,\n    ),\n  );\n}\n\n/**\n * Set background color using 24bit rgb.\n * `color` can be a number in range `0x000000` to `0xffffff` or\n * an `Rgb`.\n *\n * To produce the color magenta:\n *\n * ```ts\n * import { bgRgb24 } from \"@std/fmt/colors\";\n *\n * bgRgb24(\"foo\", 0xff00ff);\n * bgRgb24(\"foo\", {r: 255, g: 0, b: 255});\n * ```\n * @param str text color to apply 24bit rgb to\n * @param color code\n */\nexport function bgRgb24(str: string, color: number | Rgb): string {\n  if (typeof color === \"number\") {\n    return run(\n      str,\n      code(\n        [48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff],\n        49,\n      ),\n    );\n  }\n  return run(\n    str,\n    code(\n      [\n        48,\n        2,\n        clampAndTruncate(color.r),\n        clampAndTruncate(color.g),\n        clampAndTruncate(color.b),\n      ],\n      49,\n    ),\n  );\n}\n\n// https://github.com/chalk/ansi-regex/blob/02fa893d619d3da85411acc8fd4e2eea0e95a9d9/index.js\nconst ANSI_PATTERN = new RegExp(\n  [\n    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TXZcf-nq-uy=><~]))\",\n  ].join(\"|\"),\n  \"g\",\n);\n\n/**\n * Remove ANSI escape codes from the string.\n * @param string to remove ANSI escape codes from\n *\n *  @deprecated (will be removed in 1.0.0) Use {@linkcode stripAnsiCode} instead.\n */\nexport function stripColor(string: string): string {\n  return stripAnsiCode(string);\n}\n\n/**\n * Remove ANSI escape codes from the string.\n *\n * @param string to remove ANSI escape codes from\n */\nexport function stripAnsiCode(string: string): string {\n  return string.replace(ANSI_PATTERN, \"\");\n}\n", "// shims\nimport \"./shims.ts\";\n\nexport * as readable from \"./readable/mod.ts\";\nexport * as writable from \"./writable/mod.ts\";\nexport * as transform from \"./transform/mod.ts\";\nexport * from \"./transporter/mod.ts\";\n\nexport { default as package } from \"./deno.json\" with { type: \"json\" };\n", "/**\nCheck if a value is a plain object.\n\nAn object is plain if it's created by either `{}`, `new Object()`, or `Object.create(null)`.\n\n@example\n```\nimport isPlainObject from 'is-plain-obj';\nimport {runInNewContext} from 'node:vm';\n\nisPlainObject({foo: 'bar'});\n//=> true\n\nisPlainObject(new Object());\n//=> true\n\nisPlainObject(Object.create(null));\n//=> true\n\n// This works across realms\nisPlainObject(runInNewContext('({})'));\n//=> true\n\nisPlainObject([1, 2, 3]);\n//=> false\n\nclass Unicorn {}\nisPlainObject(new Unicorn());\n//=> false\n\nisPlainObject(Math);\n//=> false\n```\n*/\nexport default function isPlainObject<Value>(\n  value: unknown,\n): value is Record<PropertyKey, Value>;\n\nexport default function isPlainObject<Value>(\n  value: unknown,\n): value is Record<PropertyKey, Value> {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return (prototype === null || prototype === Object.prototype ||\n    Object.getPrototypeOf(prototype) === null) &&\n    !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n", "import isPlainObject from \"../utils/is-plain-object.ts\";\n\ntype GeneratorFunc<T> = () => IterableIterator<T>;\ntype AsyncGeneratorFunc<T> = () => AsyncIterableIterator<T>;\n\ntype FromObject<T> = [string, T][]; // { [s: string]: T; } | ArrayLike<T>\n\ntype FromType<T> =\n  | AsyncIterable<T>\n  | Iterable<T>\n  | GeneratorFunc<T>\n  | AsyncGeneratorFunc<T>\n  | ReadableStream<T>\n  | TransformStream<T, T>;\n\ntype FromIterable<T> =\n  | AsyncIterable<T>\n  | Iterable<T>\n  | GeneratorFunc<T>\n  | AsyncGeneratorFunc<T>\n  | ReadableStream<T>;\n\n// function isFoo<T extends Record<string, never>>(obj: T): obj is T {\n//   return (obj as T).foo !== undefined;\n// }\n\nconst isTransformStream = (input: object): input is TransformStream =>\n  (input instanceof TransformStream) ||\n  (\"readable\" in input && \"writable\" in input);\n\nexport function from<R>(\n  input: FromType<R>,\n): ReadableStream<R> {\n  if (isTransformStream(input)) {\n    return input.readable;\n  }\n\n  return readableFromIterable(input);\n}\n\nexport const of = <T extends unknown[]>(\n  ...args: T\n): ReadableStream<T[number]> => from(args as T[number][]);\n\nexport function readableFromIterable<T>(\n  iterable: FromIterable<T>,\n): ReadableStream<T> {\n  if (typeof iterable === \"function\") {\n    iterable = iterable();\n  }\n\n  return new ReadableStream<T>({\n    async pull(controller) {\n      for await (const chunk of iterable) {\n        controller.enqueue(await chunk);\n      }\n      controller.close();\n    },\n  });\n}\n\nexport function readableFromObject<T>(input: T): ReadableStream<string> {\n  if (isPlainObject(input)) {\n    const str = JSON.stringify(input, null, 2);\n    const lines = str.split(\"\\n\");\n    return readableFromIterable(lines);\n  }\n\n  console.log(\"readableFromObject\", input);\n  throw new TypeError(`Invalid input type: ${typeof input}`);\n}\n\n// const foo = from([1, \"a\"]);\n// const bar = from(new Blob().stream());\n// const baz = from(Object.entries({a:1,b:2,c:'dd'}));\n", "import { from } from \"./readable/from.ts\";\n\nexport async function* ReadableStreamIterator<R>(this: ReadableStream<R>) {\n  const reader = this.getReader();\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nif (!(\"from\" in ReadableStream)) {\n  console.log(\"(shim) ReadableStream.from\");\n  Object.defineProperty(ReadableStream, \"from\", {\n    value: from,\n  });\n}\n\nif (typeof ReadableStream.prototype[Symbol.asyncIterator] === \"undefined\") {\n  console.log(\"(shim) ReadableStream.prototype[Symbol.asyncIterator]\");\n  Object.defineProperty(ReadableStream.prototype, Symbol.asyncIterator, {\n    value: ReadableStreamIterator,\n  });\n}\n", "export * from \"./from-body.ts\";\nexport * from \"./from-fetch.ts\";\nexport * from \"./from.ts\";\nexport * from \"./from-timer.ts\";\nexport * from \"./external.ts\";\nexport * from \"./from-event.ts\";\nexport * from \"./from-generator.ts\";\nexport * from \"./from-iterable.ts\";\nexport * from \"./just.ts\";\nexport * from \"./range.ts\";\nexport * from \"./read.ts\";\nexport * from \"./consume.ts\";\n\nexport function readable<T>(\n  start:\n    | ((controller: ReadableStreamDefaultController<T>) => void)\n    | undefined,\n  rest?: Omit<UnderlyingDefaultSource<T>, \"start\">,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    start,\n    ...rest,\n  });\n}\n", "import { readable, transform } from \"../mod.ts\";\n\n/**\n * Retrieves the body of a request or response as a ReadableStream.\n * If the body is already a ReadableStream, it is returned as is.\n * Otherwise, a TypeError is thrown.\n *\n * @param input - The request or response object.\n * @returns The body as a ReadableStream.\n * @throws {TypeError} If the body is not a ReadableStream.\n */\nexport function fromBody(\n  input: Request | Response,\n): ReadableStream<string> {\n  const isRequest = input instanceof Request;\n  const isResponse = input instanceof Response;\n\n  if (isRequest || isResponse) {\n    if (input.body) {\n      return readable.from(input.body)\n        .pipeThrough(transform.decode());\n    }\n  }\n\n  throw new TypeError(`Invalid body type: ${typeof input.body}`);\n}\n", "import { fromBody } from \"./from-body.ts\";\n\nexport async function fromFetch(\n  input: URL | RequestInfo,\n  init?: RequestInit,\n): Promise<ReadableStream<string>> {\n  return fromBody(await fetch(new Request(input, init)));\n}\n", "import type { Readable } from \"../types.ts\";\n\n/**\n * Creates an observable that will forever emit `chunk()` every `ms` milliseconds.\n *\n * @param ms Milliseconds between each emit.\n * @returns New observable that emits null values.\n */\nexport function fromTimer<T>(\n  ms: number,\n  chunk: () => T = () => null as T,\n): Readable<T> {\n  let id: number;\n\n  return new ReadableStream<T>({\n    start(controller) {\n      id = setInterval(() => {\n        controller.enqueue(chunk());\n      }, ms);\n    },\n    cancel() {\n      clearInterval(id);\n    },\n  });\n}\n\nexport const every = fromTimer;\n", "/**\n * Symbol indicating the end of a stream. Used with `external`.\n */\n// @ts-ignore ?\nexport const EOF: symbol = Symbol();\nexport type NextFunc<T> = (v: T | typeof EOF) => void;\n\n/**\n * Utility function to create new observables from external sources.\n * Returns an object with two values: the new observable, and a `next` function\n * which will emit a value to `observable` when called.\n * Calling `next` with `EOF` will indicate there are no more values to emit.\n *\n * @typeparam T Type of items to be emitted by the observable.\n */\nexport function external<T>(): {\n  observable: ReadableStream<T>;\n  next: NextFunc<T>;\n} {\n  let next: NextFunc<T>;\n  const observable = new ReadableStream<T>(\n    {\n      start(controller) {\n        next = (v: T | typeof EOF) => {\n          if (v === EOF) {\n            return controller.close();\n          }\n          controller.enqueue(v as T);\n        };\n      },\n    },\n    { highWaterMark: 0 },\n  );\n  return { observable, next: next! };\n}\n", "import type { Readable } from \"../types.ts\";\n\n/**\n * Creates an observable from an `EventTarget`.\n * Each event is turned into an item for the observable.\n *\n * @typeparam K Type of the event target `el`.\n * @typeparam T Type of the events to be emitted, such as `MouseEvent`.\n * @param el Event target to create an observable from.\n * @param name Name of the event to listen to, such as `'click'`.\n * @returns New observable that emits values from the event target.\n */\nexport function fromEvent<K extends HTMLElement, T extends Event = Event>(\n  el: K,\n  name: string,\n  options?: boolean | AddEventListenerOptions,\n): Readable<T> {\n  let listener: EventListener;\n  return new ReadableStream<T>(\n    {\n      start(controller) {\n        listener = (e) => controller.enqueue(e as T);\n        el.addEventListener(name, listener, options);\n      },\n      cancel() {\n        el.removeEventListener(name, listener, options);\n      },\n    },\n    { highWaterMark: 0 },\n  );\n}\n", "import type { Readable } from \"../types.ts\";\nimport { EOF, external } from \"./external.ts\";\n\n/**\n * Creates an observable from a synchronous iterable.\n *\n * @typeparam T Type of items to be emitted by the observable.\n * @param it Iterable to create an observable from.\n * @returns New observable that emits values from the iterable.\n */\nexport function fromIterable<T>(\n  it: Iterable<T> | IterableIterator<T>,\n): Readable<T> {\n  const { next, observable } = external<T>();\n  for (const v of it) {\n    next(v);\n  }\n  next(EOF);\n  return observable;\n}\n", "import type { Readable } from \"../types.ts\";\nimport { fromIterable } from \"./from-iterable.ts\";\n\ntype GeneratorFunc<T> = () => IterableIterator<T>;\n\n/**\n * Creates an observable from a generator that takes no arguments.\n *\n * @typeparam T Type of items to be emitted by the observable.\n * @param f Generator function to create an observable from.\n * @returns New observable that emits values from the generator.\n */\nexport function fromGenerator<T>(f: GeneratorFunc<T>): Readable<T> {\n  return fromIterable(f());\n}\n\nfunction* x() {\n  yield \"one\";\n  yield \"two\";\n}\n\nfromGenerator(x);\n", "import type { Readable } from \"../types.ts\";\nimport { EOF, external } from \"./external.ts\";\n\n/**\n * Creates an observable that emits a set of values.\n *\n * @typeparam T Type of the emitted value.\n * @param vs Values to emit.\n * @returns New observable that emits the given values before ending.\n */\nexport function just<T>(...vs: T[]): Readable<T> {\n  const { next, observable } = external<T>();\n  for (const v of vs) {\n    next(v);\n  }\n  next(EOF);\n  return observable;\n}\n", "import type { Readable } from \"../types.ts\";\nimport { EOF, external } from \"./external.ts\";\n\n/**\n * Creates an observable that emits numbers from `start` to `end`.\n *\n * @param start Number to start emitting from, such as `0`.\n * @param end Number to stop emitting at, inclusive.\n * @returns New observable that emits numbers.\n */\nexport function range(start: number, end: number): Readable<number> {\n  const { observable, next } = external<number>();\n  const len = Math.abs(end - start);\n  const dir = Math.sign(end - start);\n  for (let i = 0; i <= len; i++) {\n    next(start + i * dir);\n  }\n  next(EOF);\n  return observable;\n}\n", "export const read = (\n  cb: CallableFunction,\n): <T>(stream: ReadableStream<T>) => Promise<void> => {\n  return async <T>(stream: ReadableStream<T>) => {\n    for await (const chunk of stream) {\n      await cb(chunk);\n    }\n  };\n};\n", "/**\n * Consumes a ReadableStream by applying a function to each chunk.\n * @param fn - The function to apply to each chunk of the ReadableStream.\n * @returns A function that accepts a ReadableStream and consumes it using the provided function.\n */\nexport function consume<T>(\n  fn: (chunk: T) => unknown,\n): (input: ReadableStream<T>) => Promise<void>;\n\n/**\n * Consumes a ReadableStream using a provided function.\n * @param readable - The ReadableStream to consume.\n * @returns A function that accepts a function to apply to each chunk of the ReadableStream and consumes it.\n */\nexport function consume<T>(\n  readable: ReadableStream<T>,\n): (fn: (chunk: T) => unknown) => Promise<void>;\n\n/**\n * Consumes a ReadableStream by applying a function to each chunk.\n * @param readable - The ReadableStream to consume.\n * @param fn - The function to apply to each chunk of the ReadableStream.\n * @returns A Promise that resolves when the ReadableStream has been fully consumed.\n */\nexport async function consume<T>(\n  readable: ReadableStream<T>,\n  fn: (chunk: T) => unknown,\n): Promise<void>;\n\n/**\n * Consumes a ReadableStream or a function by applying a function to each chunk.\n * @param readable - The ReadableStream or function to consume.\n * @param fn - The function to apply to each chunk of the ReadableStream.\n * @returns A function that accepts a ReadableStream and consumes it using the provided function, or a function that accepts a function to apply to each chunk of the ReadableStream and consumes it.\n */\nexport function consume<T>(\n  readable: ReadableStream<T> | ((chunk: T) => unknown),\n  fn?: (chunk: T) => unknown,\n) {\n  if (readable instanceof ReadableStream) {\n    if (!fn) return (fn: (chunk: T) => unknown) => consume(readable, fn);\n\n    return (async () => {\n      for await (const chunk of readable) await fn(chunk);\n    })();\n  }\n\n  if (typeof readable === \"function\") {\n    return (input: ReadableStream<T>) => consume(input, readable);\n  }\n}\n\n/**\n * Example function that demonstrates the usage of the `consume` function.\n */\nfunction _example() {\n  const readable = new ReadableStream<string>();\n  const log = (chunk: string) => console.log(chunk);\n\n  consume(readable, log);\n\n  consume(readable)(log);\n\n  consume(log)(readable);\n}\n", "export * from \"./subscribe.ts\";\nexport * from \"./write.ts\";\n", "/**\n * Sink for observables that discards all values.\n * Useful to leave at the end of a chain.\n *\n * @typeparam T Type of items emitted by the observable.\n * @param f Function to call for each value before it\u2019s discarded.\n */\nexport function subscribe<T>(f: (v: T) => void = () => {}): WritableStream<T> {\n  return new WritableStream<T>(\n    {\n      write(chunk: T) {\n        f(chunk);\n      },\n    },\n    { highWaterMark: 1 },\n  );\n}\n", "import type { Writable } from \"../types.ts\";\n\nexport function write<T>(writable: Writable<T>): (chunk: T) => Promise<void> {\n  const writer = writable.getWriter();\n\n  return async function w(chunk: T): Promise<void> {\n    await writer.ready;\n    await writer.write(chunk);\n  };\n}\n", "export * from \"./each.ts\";\nexport * from \"./lower-case.ts\";\nexport * from \"./map.ts\";\nexport * from \"./pipe.ts\";\nexport * from \"./tap.ts\";\nexport * from \"./text.ts\";\nexport * from \"./upper-case.ts\";\nexport * from \"./log.ts\";\nexport * from \"./to.ts\";\nexport * from \"./to-uint8array.ts\";\n// export * from \"./transform/to-string.ts\";\n// export * from \"./transform/to-number.ts\";\nexport * from \"./debounce.ts\";\nexport * from \"./filter.ts\";\nexport * from \"./check.ts\";\nexport * from \"./apply.ts\";\nexport * from \"./sse.ts\";\n", "import type { Transform } from \"../types.ts\";\n\n/**\n * Calls a function for each item emitted by an observable without\n * waiting for the function to return to forward the item.\n * Exceptions thrown by the function will be caught and ignored.\n *\n * @typeparam T Type of items emitted by the observable.\n * @param f Function called with each emitted value.\n * @returns Transform that emits the same items as the original observable.\n */\nexport function each<T>(\n  f: (x: T) => Promise<unknown> | unknown,\n): Transform<T> {\n  return new TransformStream<T, T>(\n    {\n      async transform(chunk, controller) {\n        controller.enqueue(chunk);\n        try {\n          await f(chunk);\n        } catch {\n          // catch\n        }\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "import type { Transform } from \"../types.ts\";\n\nexport function toLowerCase(): Transform<string> {\n  return new TransformStream<string, string>({\n    transform(chunk, controller) {\n      return controller.enqueue(chunk.toLowerCase());\n    },\n  });\n}\n", "import type { Transform } from \"../types.ts\";\n\n/**\n * Returns a `Transform` with the results of applying the given function\n * to each emitted item of the original observable.\n *\n * @typeparam S Type of items emitted by the original observable.\n * @typeparam T Type of items returned by `f`.\n * @param f Function called with each emitted item. If it returns a promise,\n * the result is awaited then emitted.\n * @returns Transform that emits items produced by `f`.\n */\nexport function map<S, T>(f: (x: S) => T | Promise<T>): Transform<S, T> {\n  return new TransformStream<S, T>(\n    {\n      async transform(chunk, controller) {\n        controller.enqueue(await f(chunk));\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "// deno-lint-ignore-file\nimport * as colors from \"./colors.ts\";\n\nexport { colors };\nexport const idKey = \"transport-id\";\n\nexport const isDebug = (): boolean =>\n  typeof Deno !== \"undefined\"\n    ? Deno.env.get(\"DEBUG\") === \"true\"\n    : Boolean(Reflect.get(globalThis, \"DEBUG\"));\n\nObject.assign(globalThis, { isDebug });\n\nconsole.log(\n  colors.green(\"(utils) DEBUG\") + \"=\" +\n    colors.white(isDebug() + \"\"),\n);\n\nexport function mkId<K extends string>(key: K = \"abcdefghkl\" as K) {\n  if (key.length !== 10) {\n    throw new TypeError(\n      `Key format error, required 10 unique chars, got: \"${key}\" (len=${key.length})`,\n    );\n  }\n  const alphaMap = [...key];\n\n  return <I extends string = \"0123456789\">(value: I): K[0] =>\n    [...String(value)].map((num) => alphaMap[Number(num)]).join(\"\");\n}\n\nexport const tid = mkId(\"5aksj3hg7e\".toUpperCase());\nexport const uid = () => tid(Math.random().toString().split(\".\").pop()!);\n\nexport async function delay(ms: number): Promise<unknown> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nexport enum ReadyState {\n  CONNECTING = 0,\n  INCOMING = 1,\n  OUTGOING = 2,\n  OPEN = 3,\n  CLOSED = 4,\n  ERRORED = 5,\n}\n\nexport function* mkRangeIterator(\n  start = 0,\n  end = Infinity,\n  step = 1,\n): Generator<number, number, unknown> {\n  let iterationCount = 0;\n  for (let i = start; i < end; i += step) {\n    iterationCount++;\n    yield i;\n  }\n  return iterationCount;\n}\n\nexport async function* mkRangeAsyncIterator(\n  start = 0,\n  end = Infinity,\n  delay = 100,\n): AsyncGenerator<unknown, number, unknown> {\n  let iterationCount = 0;\n  for (let i = start; i < end; i += 1) {\n    iterationCount++;\n    yield await new Promise((resolve) => {\n      setTimeout(() => resolve(i), delay);\n    });\n  }\n  return iterationCount;\n}\n\nexport const swapObject = <T extends { [key: PropertyKey]: any }>(\n  obj: T,\n): {\n  [K in keyof T as T[K]]: K;\n} => Object.fromEntries(Object.entries(obj).map(([k, v]) => [v, k]));\n\nexport const valueFromKeyObject = <T extends { [key: PropertyKey]: any }>(\n  obj: T,\n): {\n  [K in keyof T]: K;\n} => Object.fromEntries(Object.entries(obj).map(([k, _v]) => [k as any, k]));\n\nexport const _isTransformStream = <T extends object>(input: T): boolean =>\n  typeof input === \"object\" &&\n  Object.hasOwn(input, \"writable\") && Object.hasOwn(input, \"readable\");\n\nexport const isTransformStream = (a: unknown): a is GenericTransformStream =>\n  typeof a === \"object\" && \"readable\" in a!;\n\ntype LengthOfTuple<T extends any[]> = T extends { length: infer L } ? L\n  : never;\ntype DropFirstInTuple<T extends any[]> = ((...args: T) => any) extends\n  (arg: any, ...rest: infer U) => any ? U : T;\nexport type LastInTuple<T extends any[]> =\n  T[LengthOfTuple<DropFirstInTuple<T>>];\n", "import type {\n  StrictStream,\n  StrictStreamMapper,\n  StrictStreamPlumber,\n} from \"../types.ts\";\nimport { isTransformStream } from \"../utils.ts\";\n\nexport const transform =\n  <I, O>(transform: TransformStream<I, O>) =>\n  (input: ReadableStream<I>): ReadableStream<O> => {\n    return input.pipeThrough(transform);\n  };\n\nexport function pipe<In, Out>(\n  mapper: StrictStreamMapper<In, Out> | TransformStream<In, Out>,\n): StrictStreamPlumber<In, Out> {\n  const streamMapper: StrictStreamMapper<In, Out> = (input: StrictStream<In>) =>\n    isTransformStream(mapper) ? transform(mapper)(input) : mapper(input);\n\n  // todo: make it work\n  if (isTransformStream(mapper)) {\n    Object.defineProperties(streamMapper, {\n      readable: {\n        get: () => mapper.readable,\n        enumerable: true,\n      },\n      writable: {\n        get: () => mapper.writable,\n        enumerable: true,\n      },\n    });\n  }\n\n  // @ts-ignore ?\n  streamMapper.pipe = <Output>(\n    mapper: StrictStreamMapper<Out, Output> | TransformStream<Out, Output>,\n  ) => {\n    return pipe<In, Output>((input: StrictStream<In>) => {\n      const nextStream = streamMapper(input);\n      return isTransformStream(mapper)\n        ? transform(mapper)(nextStream)\n        : mapper(nextStream);\n    });\n  };\n\n  return streamMapper as StrictStreamPlumber<In, Out>;\n}\n", "import type { Transform } from \"../types.ts\";\nimport { each } from \"./each.ts\";\n\n/**\n * Alias for {@link each}.\n */\nexport function tap<T>(f: (x: T) => void): Transform<T, T> {\n  return each(f);\n}\n", "import type { Transform } from \"../types.ts\";\n\nexport function encode(): TextEncoderStream;\n\nexport function encode(\n  input: ReadableStream<string>,\n): ReadableStream<Uint8Array>;\n\nexport function encode(\n  input?: ReadableStream<string>,\n): ReadableStream<Uint8Array> | Transform<string, Uint8Array> {\n  return input\n    ? input.pipeThrough(new TextEncoderStream())\n    : new TextEncoderStream();\n}\n\nexport function decode(): TextDecoderStream;\n\nexport function decode(\n  input: ReadableStream<Uint8Array>,\n): ReadableStream<string>;\n\nexport function decode(\n  input?: ReadableStream<Uint8Array>,\n): ReadableStream<string> | Transform<Uint8Array, string> {\n  return input\n    ? input.pipeThrough(new TextDecoderStream())\n    : new TextDecoderStream();\n}\n", "import type { Transform } from \"../types.ts\";\n\nexport function toUpperCase(): Transform<string> {\n  return new TransformStream<string, string>({\n    transform(chunk, controller) {\n      return controller.enqueue(chunk.toUpperCase());\n    },\n  });\n}\n", "import type { Transform } from \"../types.ts\";\n\nexport function log<T>(tag: string = \"\"): Transform<T> {\n  return new TransformStream<T, T>(\n    {\n      start() {\n        console.warn(tag, \"started\");\n      },\n      async transform(chunk, controller) {\n        controller.enqueue(chunk);\n        console.log(tag, await chunk);\n      },\n      async cancel(reason) {\n        await Promise.resolve(console.warn(tag, \"canceled\", reason));\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "import type { IOFunction } from \"../app/types.ts\";\nimport type { Transform } from \"../types.ts\";\nimport { map } from \"./map.ts\";\n\nexport const to = <I, O>(\n  func: IOFunction<I, O>,\n): Transform<I, O> => map(func);\n\nexport const newNumber = <T>(input: T): Number => new Number(input);\nexport const toNumeric = <I>(): Transform<any, number> => to(Number);\nexport const toNumber = <I>(): Transform<I, Number> =>\n  to((input: I) => new Number(input));\nexport const toString = <I>(): Transform<I, string> => to<I, string>(String);\n\nexport const toLine = <I extends string>(\n  separator = \"\\n\",\n): Transform<I, string> => to((i: I) => i.concat(separator));\n\nexport const toFixed = <I>(fd?: number): Transform<I, string> => {\n  const fn = (fd?: number) => <T>(input: T) => (new Number(input)).toFixed(fd);\n  const mapper = fn(fd)<I>;\n\n  return to(mapper);\n};\n\nexport const toPrecision = <I>(precision?: number): Transform<I, string> => {\n  const fn = (fd?: number) => <T>(input: T) =>\n    (new Number(input)).toPrecision(fd);\n  const mapper = fn(precision)<I>;\n\n  return to(mapper);\n};\n\nconst alphaMap: [string, ...string[]] = [\n  \"o\", // = 0\n  \"i\", // = 1\n  \"2\", // = 2\n  \"e\", // = 3\n  \"q\", // = 4\n  \"f\", // = 5\n  \"s\", // = 6\n  \"x\", // = 7\n  \"6\", // = 8\n  \"n\", // = 9\n  \".\", // = .\n];\n\nexport const toNumAlpha = <T extends number | string>(): Transform<T, string> =>\n  map<T, string>((value) =>\n    [...String(value)].map((num) => alphaMap[Number(num)]).join(\"\")\n  );\n\nexport const toAlphaNum = <T extends string | number>(): Transform<T, number> =>\n  map<T, number>((value) =>\n    Number([...String(value)].map((char) => alphaMap.indexOf(char)).join(\"\"))\n  );\n", "export class Uint8ArrayTransformStream<T> extends TransformStream<\n  T,\n  Uint8Array\n> {\n  constructor() {\n    const encoder = new TextEncoder();\n\n    super({\n      start() {}, // required.\n      async transform(chunk, controller) {\n        chunk = await chunk;\n        switch (typeof chunk) {\n          case \"object\":\n            // just say the stream is done I guess\n            if (chunk === null) {\n              controller.terminate();\n            } else if (ArrayBuffer.isView(chunk)) {\n              controller.enqueue(\n                new Uint8Array(\n                  chunk.buffer,\n                  chunk.byteOffset,\n                  chunk.byteLength,\n                ),\n              );\n            } else if (\n              Array.isArray(chunk) &&\n              chunk.every((value) => typeof value === \"number\")\n            ) {\n              controller.enqueue(new Uint8Array(chunk));\n            } else if (\n              typeof chunk.valueOf === \"function\" &&\n              chunk.valueOf() !== chunk\n            ) {\n              this.transform!(chunk.valueOf() as T, controller); // hack\n            } else if (\"toJSON\" in chunk) {\n              this.transform!(JSON.stringify(chunk) as T, controller);\n            }\n            break;\n          case \"symbol\":\n            controller.error(\"Cannot send a symbol as a chunk part\");\n            break;\n          case \"undefined\":\n            controller.error(\"Cannot send undefined as a chunk part\");\n            break;\n          default:\n            controller.enqueue(encoder.encode(String(chunk)));\n            break;\n        }\n      },\n      flush() {\n        /* do any destructor work here */\n      },\n    });\n  }\n}\n\nexport function toUint8Array<T>(): Uint8ArrayTransformStream<T> {\n  return new Uint8ArrayTransformStream<T>();\n}\n", "import type { Transform } from \"../types.ts\";\n\n/**\n * Returns a `Transform` where items are only emitted if `ms` milliseconds\n * pass without new a new emit by the source observable. If a new value is\n * emitted, the \u201Ccooldown\u201D is restarted and the old value is discarded.\n *\n * @typeparam T Type of items emitted by the observable.\n * @param ms Milliseconds to wait before emitting an item.\n * @returns Transform that emits some items from the original observable.\n */\nexport function debounce<T>(ms: number): Transform<T> {\n  let timeout: number;\n  let timeoutP: Promise<unknown>;\n  let savedChunk: T;\n  return new TransformStream(\n    {\n      transform(chunk, controller) {\n        savedChunk = chunk;\n        if (timeout > 0) {\n          clearTimeout(timeout);\n        }\n        timeoutP = new Promise((resolve) => {\n          // @ts-ignore NodeJS types are interfering here\n          timeout = setTimeout(() => {\n            controller.enqueue(savedChunk);\n            timeout = 0;\n            resolve(undefined);\n          }, ms);\n        });\n      },\n      async flush() {\n        await timeoutP;\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "import type { Transform } from \"../types.ts\";\n\n/**\n * Returns a `Transform` that emits all items for which `f` returns true.\n *\n * @typeparam T Type of items emitted by the observable.\n * @param f Function called with each emitted item. If it returns `true`, the\n * item is emitted. Otherwise the item is discarded.\n * @returns Transform that emits some items from the original observable.\n */\nexport function filter<T>(f: (x: T) => boolean): Transform<T> {\n  return new TransformStream<T, T>(\n    {\n      transform(chunk, controller) {\n        if (f(chunk)) {\n          controller.enqueue(chunk);\n        }\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "import type { Transform } from \"../types.ts\";\n\nexport function check<T>(f: (x: T) => boolean, message?: string): Transform<T> {\n  return new TransformStream<T, T>(\n    {\n      transform(chunk, controller) {\n        if (!f(chunk)) {\n          throw new TypeError(\n            `Check Failed: ${\n              message ||\n              \"type: \" + typeof chunk + \" validate func: \" + String(f)\n            }`,\n          );\n        }\n        controller.enqueue(chunk);\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "import type { Transform } from \"../types.ts\";\n\n/**\n * Applies a transformer function to create a Transform stream.\n *\n * @template S The type of the input data.\n * @template T The type of the transformed data.\n * @param {TransformerTransformCallback<S, T>} transformer The transformer function to apply to each chunk of data.\n * @returns {Transform<S, T>} The Transform stream.\n */\nexport function apply<S, T>(\n  transformer: TransformerTransformCallback<S, T>,\n): Transform<S, T> {\n  return new TransformStream<S, T>(\n    {\n      async transform(chunk, controller) {\n        try {\n          await transformer(chunk, controller);\n        } catch (e) {\n          controller.error(e);\n        }\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n *\n * Based on code from the {@link https://github.com/EventSource/eventsource | EventSource module},\n * which is licensed under the MIT license. And copyrighted the EventSource GitHub organisation.\n */\nimport type { EventParseCallback, SSEParser } from \"./types.ts\";\n\n/**\n * Creates a new EventSource parser.\n *\n * @param onParse - Callback to invoke when a new event is parsed, or a new reconnection interval\n *                  has been sent from the server\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(onParse?: EventParseCallback): SSEParser {\n  // Processing state\n  let isFirstChunk: boolean;\n  let buffer: string;\n  let startingPosition: number;\n  let startingFieldLength: number;\n\n  // Event state\n  let eventId: string | undefined;\n  let eventName: string | undefined;\n  let data: string;\n  let comment: string | undefined;\n  let to: number | \"*\" | undefined;\n  let rest: { [key: string]: unknown } = {};\n\n  // result\n  let result: { [key: PropertyKey]: unknown } | undefined;\n\n  reset();\n  Object.defineProperty(feed, \"buffer\", { get: () => buffer });\n  feed.reset = reset;\n  return { push: feed, reset };\n\n  function reset(): void {\n    isFirstChunk = true;\n    buffer = \"\";\n    startingPosition = 0;\n    startingFieldLength = -1;\n    result = undefined;\n\n    eventId = undefined;\n    eventName = undefined;\n    comment = undefined;\n    // @ts-ignore .\n    data = undefined;\n    to = undefined;\n    rest = {};\n  }\n\n  function feed(chunk: string = \"\") {\n    if (result) {\n      reset();\n    }\n\n    buffer = buffer ? buffer + chunk : chunk;\n\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream.\n    // Note that we do not strip any non - UTF8 BOM, as eventsource streams are\n    // always decoded as UTF8 as per the specification.\n    if (isFirstChunk && hasBom(buffer)) {\n      buffer = buffer.slice(BOM.length);\n    }\n\n    isFirstChunk = false;\n\n    // Set up chunk-specific processing state\n    const length = buffer.length;\n    let position = 0;\n    let discardTrailingNewline = false;\n\n    // Read the current buffer byte by byte\n    while (position < length) {\n      // EventSource allows for carriage return + line feed, which means we\n      // need to ignore a linefeed character if the previous character was a\n      // carriage return\n      // @todo refactor to reduce nesting, consider checking previous byte?\n      // @todo but consider multiple chunks etc\n      if (discardTrailingNewline) {\n        if (buffer[position] === \"\\n\") {\n          ++position;\n        }\n        discardTrailingNewline = false;\n      }\n\n      let lineLength = -1;\n      let fieldLength = startingFieldLength;\n      let character: string;\n\n      for (\n        let index = startingPosition;\n        lineLength < 0 && index < length;\n        ++index\n      ) {\n        character = buffer[index];\n        if (character === \":\" && fieldLength < 0) {\n          fieldLength = index - position;\n        } else if (character === \"\\r\") {\n          discardTrailingNewline = true;\n          lineLength = index - position;\n        } else if (character === \"\\n\") {\n          lineLength = index - position;\n        }\n      }\n\n      if (lineLength < 0) {\n        startingPosition = length - position;\n        startingFieldLength = fieldLength;\n        break;\n      } else {\n        startingPosition = 0;\n        startingFieldLength = -1;\n      }\n\n      parseEventStreamLine(buffer, position, fieldLength, lineLength);\n\n      position += lineLength + 1;\n    }\n\n    if (position === length) {\n      // If we consumed the entire buffer to read the event, reset the buffer\n      buffer = \"\";\n    } else if (position > 0) {\n      // If there are bytes left to process, set the buffer to the unprocessed\n      // portion of the buffer only\n      buffer = buffer.slice(position);\n    }\n\n    return result || feed;\n  }\n\n  function parseEventStreamLine(\n    lineBuffer: string,\n    index: number,\n    fieldLength: number,\n    lineLength: number,\n  ) {\n    if (lineLength === 0) {\n      // We reached the last line of this event\n      // if (data.length > 0) {\n      result = {\n        type: \"event\",\n        id: eventId as unknown as number,\n        to,\n        // @ts-ignore >\n        event: eventName || undefined,\n        comment,\n        data: data ? data.slice(0, -1) : data, // remove trailing newline,\n        ...rest,\n      };\n\n      if (typeof onParse === \"function\") {\n        // @ts-ignore .\n        onParse(result);\n      }\n      to = undefined;\n      // @ts-ignore .\n      data = undefined;\n      comment = undefined;\n      eventId = undefined;\n\n      // }\n\n      eventName = undefined;\n      return;\n    }\n\n    const noValue = fieldLength < 0;\n    const field = lineBuffer.slice(\n      index,\n      index + (noValue ? lineLength : fieldLength),\n    );\n    let step = 0;\n\n    if (noValue) {\n      step = lineLength;\n    } else if (lineBuffer[index + fieldLength + 1] === \" \") {\n      step = fieldLength + 2;\n    } else {\n      step = fieldLength + 1;\n    }\n\n    const position = index + step;\n    const valueLength = lineLength - step;\n    const value = lineBuffer.slice(position, position + valueLength).toString();\n\n    if (field === \"data\") {\n      if (!data) {\n        data = \"\";\n      }\n      data += value ? `${value}\\n` : \"\\n\";\n      // if (value) {\n      //   data = `${data}${value}\\n`\n      // }\n    } else if (field === \"event\") {\n      eventName = value;\n    } else if (field === \"\") {\n      comment = value;\n    } else if (field === \"id\" && !value.includes(\"\\u0000\")) {\n      eventId = value;\n    } else if (field === \"to\") {\n      to = value === \"*\" ? value : Number(value);\n    } else if (field === \"retry\") {\n      const retry = parseInt(value, 10);\n      if (!Number.isNaN(retry)) {\n        // @ts-ignore .\n        if (typeof onParse === \"function\") {\n          // @ts-ignore .\n          onParse({ type: \"reconnect-interval\", value: retry });\n        } else {\n          rest.type = \"reconnect-interval\";\n          rest.retry = retry;\n        }\n      }\n    } else {\n      rest[field] = value;\n    }\n  }\n}\n\nconst BOM = [239, 187, 191];\n\nfunction hasBom(buffer: string) {\n  return BOM.every((charCode: number, index: number) =>\n    buffer.charCodeAt(index) === charCode\n  );\n}\n", "import type { EventSourceMessage } from \"./EventSourceMessage.ts\";\nimport { createParser } from \"./parser.ts\";\n\nexport function parse(\n  input: string,\n): EventSourceMessage {\n  const result = createParser().push(input);\n\n  if (typeof result === \"function\") {\n    throw new TypeError(`Parse failed`);\n  }\n\n  return result; // new EventSourceMessage(result);\n}\n", "import type { EventSourceMessage } from \"./EventSourceMessage.ts\";\n\nexport const NEWLINE_REGEXP = /\\r\\n|\\r|\\n/;\n\nexport function assertHasNoNewline(value: string, varName: string) {\n  if (value.match(NEWLINE_REGEXP) !== null) {\n    throw new RangeError(`${varName} cannot contain a newline`);\n  }\n}\n\n/**\n * Converts a server-sent message object into a string for the client.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#event_stream_format}\n */\n\nexport function stringify(\n  message: EventSourceMessage | EventSourceMessage & { [x: string]: string },\n): string {\n  const lines = [];\n  if (message.comment) {\n    assertHasNoNewline(message.comment, \"`message.comment`\");\n    lines.push(`:${message.comment}`);\n    delete message.comment;\n  }\n  if (message.event) {\n    assertHasNoNewline(message.event, \"`message.event`\");\n    lines.push(`event:${message.event}`);\n    delete message.event;\n  }\n  if (message.data) {\n    String(message.data).split(NEWLINE_REGEXP).forEach((line) =>\n      lines.push(`data:${line}`)\n    );\n    delete message.data;\n  }\n\n  if (message.id) {\n    assertHasNoNewline(message.id.toString(), \"`message.id`\");\n    lines.push(`id:${message.id}`);\n    delete message.id;\n  }\n\n  if (message.retry) {\n    lines.push(`retry:${message.retry}`);\n    delete message.retry;\n  }\n\n  const extraMessage =\n    message as (EventSourceMessage & { [x: string]: string | number });\n  const extraKeys = Object.keys(extraMessage);\n\n  for (const key of extraKeys) {\n    assertHasNoNewline(String(extraMessage[key]), \"`message.\" + key + \"`\");\n    lines.push(`${key}:${extraMessage[key]}`);\n    delete extraMessage[key];\n  }\n\n  return lines.join(\"\\n\") + \"\\n\\n\";\n}\n", "/**\n * Represents a message in the Server-Sent Event (SSE) protocol.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#fields}\n */\n\nimport { parse } from \"./parse.ts\";\nimport { stringify } from \"./stringify.ts\";\n\nexport interface EventSourceMessage {\n  /** Ignored by the client. */\n  comment?: string;\n  /** A string identifying the type of event described. */\n  event?: string;\n  /** The data field for the message. Split by new lines. */\n  data?: string;\n  /** The event ID to set the {@linkcode EventSource} object's last event ID value. */\n  id?: string | number;\n  /** The reconnection time. */\n  retry?: number;\n}\n\nexport class EventSourceMessage implements EventSourceMessage {\n  /** Ignored by the client. */\n  declare comment?: string;\n  /** A string identifying the type of event described. */\n  declare event?: string;\n  /** The data field for the message. Split by new lines. */\n  declare data?: string;\n  /** The event ID to set the {@linkcode EventSource} object's last event ID value. */\n  declare id?: string | number;\n  /** The reconnection time. */\n  declare retry?: number;\n  declare private type?: \"reconnect-interval\" | \"event\";\n  declare private readonly raw?: string;\n\n  constructor(\n    input: EventSourceMessage | string,\n    transform?: (message: EventSourceMessage) => EventSourceMessage,\n  ) {\n    if (typeof input === \"string\") {\n      const rawInput = input;\n      input = parse(input);\n      Object.defineProperty(this, \"raw\", {\n        get() {\n          return rawInput;\n        },\n      });\n    }\n\n    Object.defineProperty(this, \"type\", {\n      get: () =>\n        typeof this.retry !== \"undefined\" ? \"reconnect-interval\" : \"event\",\n    });\n\n    // const keys = [\"comment\", \"event\", \"data\", \"id\", \"retry\"] as const\n    delete input.type;\n    const keys = Object.keys(input) as [];\n\n    for (const key of keys) {\n      if (input && typeof input[key] !== \"undefined\") {\n        Object.defineProperty(this, key, {\n          value: input[key],\n          enumerable: true,\n          writable: true,\n          configurable: true,\n        });\n      }\n    }\n    // apply transform\n    if (transform) {\n      Object.assign(this, transform(this));\n    }\n  }\n\n  toString(): string {\n    return stringify(this);\n  }\n}\n", "import { EventSourceMessage } from \"./EventSourceMessage.ts\";\nimport { createParser } from \"./parser.ts\";\nimport type { SSEParser } from \"./types.ts\";\n\nexport class EventSourceDecoderStream<\n  I extends string,\n  O extends EventSourceMessage,\n> extends TransformStream<I, O> {\n  constructor() {\n    const instance = Object.create(null) as {\n      controller: TransformStreamDefaultController<O>;\n      parser: SSEParser<O>;\n    };\n\n    super(\n      {\n        start(controller) {\n          Object.assign(instance, {\n            controller,\n            parser: createParser((message) =>\n              instance.controller.enqueue(new EventSourceMessage(message) as O)\n            ),\n          });\n        },\n        transform(chunk) {\n          instance.parser.push(chunk);\n        },\n      } as Transformer<I, O>,\n    );\n  }\n}\n", "import { stringify } from \"./stringify.ts\";\nimport type { EventSourceMessage } from \"./EventSourceMessage.ts\";\n\nexport class EventSourceEncoderStream<\n  I extends EventSourceMessage,\n  O extends string,\n> extends TransformStream<I, O> {\n  constructor() {\n    super(\n      {\n        transform(message, controller) {\n          controller.enqueue(stringify(message) as O);\n        },\n      },\n    );\n  }\n}\n", "import { EventSourceDecoderStream } from \"../transporter/ess/EventSourceDecoderStream.ts\";\nimport { EventSourceEncoderStream } from \"../transporter/ess/EventSourceEncoderStream.ts\";\nimport type { EventSourceMessage } from \"../transporter/ess/EventSourceMessage.ts\";\n\nconst encoder = (): EventSourceEncoderStream<EventSourceMessage, string> =>\n    new EventSourceEncoderStream();\n\nconst decoder = (): EventSourceDecoderStream<string, EventSourceMessage> =>\n    new EventSourceDecoderStream();\n\nexport const sse = { encoder, decoder };\n", "import { colors } from \"../utils.ts\";\n\nexport const isDuplexHandler = Symbol(\"isDuplexHandler\");\n\nexport enum METHOD {\n  GET = \"GET\",\n  HEAD = \"HEAD\",\n  POST = \"POST\",\n  PUT = \"PUT\",\n  DELETE = \"DELETE\",\n  OPTIONS = \"OPTIONS\",\n  PATCH = \"PATCH\",\n  ANY = \"*\",\n}\n\nexport const STREAM_ID_KEY = \"stream-id\";\nexport const STREAM_TYPE_KEY = \"stream-type\";\nexport enum STREAM_TYPE {\n  OUTGOING = \"OUTGOING\",\n  INCOMING = \"INCOMING\",\n}\n\nexport const TransporterASCIILogo = \"\";\n", "export const isDenoEnv: boolean = Reflect.has(globalThis, \"Deno\");\n\nexport const isStreamingBodyRequest = (init?: RequestInit): boolean =>\n  init?.body instanceof ReadableStream &&\n  init.method !== \"GET\" && init.method !== \"HEAD\";\n\nexport const isTransformStream = (a: unknown): a is GenericTransformStream =>\n  typeof a === \"object\" && \"readable\" in a!;\n", "export class Promised<T> extends Promise<T> {\n  #resolve: (value: T | PromiseLike<T>) => void;\n  #reject: (reason?: unknown) => void;\n\n  resolved: boolean = false;\n  rejected: boolean = false;\n\n  constructor(\n    resolver?: (\n      resolve: (value: T | PromiseLike<T>) => void,\n      reject: (reason?: unknown) => void,\n    ) => void,\n  ) {\n    const that = Object.create(null) as {\n      resolve: (value: T | PromiseLike<T>) => void;\n      reject: (reason?: unknown) => void;\n    };\n\n    super(function (resolve, reject) {\n      Object.assign(that, {\n        resolve,\n        reject,\n      });\n    });\n\n    this.#reject = (reason?: unknown) => {\n      this.rejected = true;\n      that.reject(reason);\n    };\n    this.#resolve = (value: T | PromiseLike<T>) => {\n      this.resolved = true;\n      that.resolve(value);\n    };\n\n    if (resolver) {\n      resolver(this.#resolve, this.#reject);\n    }\n  }\n\n  resolve<V extends T>(value: V) {\n    this.#resolve(value);\n  }\n\n  reject(reason?: unknown) {\n    this.#reject(reason);\n  }\n\n  // get state() {\n  //   return promiseState(this);\n  // }\n}\n\nObject.assign(globalThis, { Promised });\n\nexport function promiseState<T>(\n  promise: Promise<T>,\n): Promise<\n  { status: string } | Awaited<T> | {\n    status: string;\n    value: { status: string } | Awaited<T>;\n  } | { status: string; reason: any }\n> {\n  const pendingState = { status: \"pending\" };\n\n  return Promise.race([promise, pendingState]).then(\n    (value) => value === pendingState ? value : { status: \"fulfilled\", value },\n    (reason) => ({ status: \"rejected\", reason }),\n  );\n}\n", "import { Promised } from \"./utils/Promised.ts\";\nimport { DuplexRequest } from \"./DuplexRequest.ts\";\nimport {\n  isDuplexHandler,\n  METHOD,\n  STREAM_ID_KEY,\n  STREAM_TYPE,\n  STREAM_TYPE_KEY,\n} from \"./contstants.ts\";\nimport {\n  Context,\n  type HandlerResponse,\n  route,\n  type RouteHandler,\n} from \"./route.ts\";\n\nconst map = new Map<\n  string,\n  {\n    [P in STREAM_TYPE]: Promised<HandlerResponse>;\n  }\n>();\n\nexport function duplexHandler<\n  H extends (\n    request: Request,\n    context?: Context | object,\n  ) => Response | Promise<Response>,\n>(handler: H): H {\n  if (isDuplexHandler in handler) {\n    return handler;\n  }\n\n  const duplex = (async (request: Request, context?: Context | object) => {\n    const id = request.headers.get(STREAM_ID_KEY);\n\n    if (!id) {\n      return handler(request, context);\n    }\n\n    const streamType = request.headers.get(\n      STREAM_TYPE_KEY,\n    ) as STREAM_TYPE;\n\n    const isHalfDuplex = !!id && !!streamType &&\n      ![METHOD.GET, METHOD.HEAD].includes(request.method as METHOD);\n\n    if (!isHalfDuplex) {\n      return handler(request, context);\n    }\n\n    if (!map.has(id)) {\n      map.set(id, {\n        INCOMING: new Promised(),\n        OUTGOING: new Promised(),\n      });\n    }\n\n    const { INCOMING, OUTGOING } = map.get(id)!;\n\n    switch (streamType) {\n      case STREAM_TYPE.OUTGOING: {\n        if (request instanceof DuplexRequest) {\n          request.response = new Response();\n        }\n\n        INCOMING.resolve(await handler(request, context));\n        map.delete(id);\n\n        return OUTGOING;\n      }\n\n      case STREAM_TYPE.INCOMING: {\n        if (\n          request instanceof DuplexRequest && request.outgoing &&\n          !request.outgoing.response\n        ) {\n          request.outgoing.response = new Response();\n\n          INCOMING.resolve(await handler(request.outgoing, context));\n          map.delete(id);\n        }\n\n        return INCOMING;\n      }\n\n      default:\n        return handler(request, context);\n    }\n  }) as H;\n\n  return Object.assign(\n    duplex,\n    {\n      [isDuplexHandler]: true,\n      handler,\n    },\n  );\n}\n", "import { STREAM_ID_KEY, STREAM_TYPE, STREAM_TYPE_KEY } from \"./contstants.ts\";\nimport { isDenoEnv, isStreamingBodyRequest } from \"./utils/is.ts\";\nimport { duplexHandler } from \"./duplexHandler.ts\";\nimport type { FetchHandler, RouteHandler } from \"./route.ts\";\n\nexport type DuplexRequestInit = RequestInit & { duplex?: \"half\" | \"full\" };\n\nexport type DuplexRequestFetch = RouteHandler;\n\n/**\n * Represents a request stream that extends the RequestDuplex class.\n */\nexport class DuplexRequest extends Request {\n  declare duplex: \"half\" | \"full\" | undefined;\n  declare outgoing: DuplexRequest | undefined;\n\n  declare response: Response | Promise<Response> | undefined;\n\n  private _fetch(\n    ...args: [\n      input: Request,\n      init?: RequestInit,\n    ]\n  ): Response | Promise<Response> {\n    return globalThis.fetch(...args);\n  }\n\n  /**\n   * Creates a new instance of RequestStream.\n   * @param input - The URL or Request object.\n   * @param init - Optional request initialization options.\n   */\n\n  constructor(\n    input: URL | RequestInfo,\n    init?: DuplexRequestInit | FetchHandler,\n    fetch?: FetchHandler,\n  ) {\n    if (typeof init === \"function\") {\n      fetch = init;\n      init = {};\n    }\n\n    input = input || \"\";\n    init = init || {};\n\n    if (isStreamingBodyRequest(init)) {\n      init.duplex = isDenoEnv ? \"full\" : \"half\";\n      init.method = init.method || \"POST\";\n    }\n\n    const headers = new Headers(init.headers);\n    headers.set(\n      STREAM_ID_KEY,\n      headers.get(STREAM_ID_KEY) || Math.random().toString().slice(2),\n    );\n\n    let outgoing;\n\n    if (init.duplex === \"half\" && !headers.has(STREAM_TYPE_KEY)) {\n      outgoing = new new.target(input, {\n        ...init,\n        headers: {\n          ...Object.fromEntries(headers.entries()),\n          [STREAM_TYPE_KEY]: STREAM_TYPE.OUTGOING,\n        },\n      });\n\n      init = {\n        body: null,\n        method: init.method,\n        headers: {\n          ...Object.fromEntries(headers.entries()),\n          [STREAM_TYPE_KEY]: STREAM_TYPE.INCOMING,\n        },\n      };\n    } else {\n      init = {\n        ...init,\n        headers,\n      };\n    }\n\n    super(input, init);\n\n    if (outgoing) {\n      Object.defineProperty(this, \"outgoing\", {\n        value: outgoing,\n      });\n    }\n\n    if (typeof fetch === \"function\") {\n      Object.defineProperty(this, \"_fetch\", {\n        value: duplexHandler(fetch),\n      });\n    }\n  }\n\n  get requestType(): STREAM_TYPE {\n    return this.headers.get(STREAM_TYPE_KEY) === STREAM_TYPE.OUTGOING\n      ? STREAM_TYPE.OUTGOING\n      : STREAM_TYPE.INCOMING;\n  }\n\n  /**\n   * Fetches the request stream.\n   * @param init - Optional request initialization options.\n   * @returns A Promise that resolves to the response of the request.\n   */\n  async fetch(init?: RequestInit): Promise<Response> {\n    try {\n      if (this.outgoing) {\n        // >> send stream.\n        this.outgoing.response = this._fetch(this.outgoing, init);\n      }\n\n      // << receive stream.\n      this.response = await this._fetch(\n        this,\n        init,\n      );\n\n      if (!this.response.ok) {\n        throw new Error(\n          `Failed to fetch. Response status: ${this.response.status} `,\n        );\n      }\n    } catch (err) {\n      console.warn(`[${this.constructor.name}] ${err.message}`);\n      console.error(err);\n\n      return this.response!;\n    }\n\n    return this.response;\n  }\n}\n", "// deno-lint-ignore-file no-explicit-any\nimport { DuplexRequest, type DuplexRequestInit } from \"./DuplexRequest.ts\";\nimport type { FetchHandler } from \"./route.ts\";\n\nexport class TransportStream<\n  W = Uint8Array,\n  R = Uint8Array,\n> {\n  static encoder(): TransformStream<any, any> {\n    return new TransformStream();\n  }\n\n  static decoder(): TransformStream<any, any> {\n    return new TransformStream();\n  }\n\n  static headers: HeadersInit = {};\n\n  writable: WritableStream<W>;\n  readable: ReadableStream<R>;\n\n  request: DuplexRequest;\n\n  finished: Promise<void>;\n\n  writer?: WritableStreamDefaultWriter<W>;\n\n  constructor(\n    input: URL | RequestInfo,\n    init?: DuplexRequestInit | FetchHandler,\n    fetch?: FetchHandler,\n  ) {\n    const reqTransform = new.target.encoder();\n    const resTransform = new.target.decoder();\n\n    this.writable = reqTransform.writable;\n    this.readable = resTransform.readable;\n\n    if (typeof init === \"function\") {\n      fetch = init;\n      init = {};\n    }\n\n    const headers = {\n      ...init?.headers,\n      ...TransportStream.headers,\n      ...new.target.headers,\n    };\n\n    const request = this.request = new DuplexRequest(input, {\n      ...init,\n      headers,\n      body: reqTransform.readable,\n    }, fetch);\n\n    this.finished = request.fetch().then((response) =>\n      response.body?.pipeTo(resTransform.writable)\n    );\n  }\n\n  async write(message: W) {\n    this.writer = this.writer || this.writable.getWriter();\n\n    await this.writer.ready;\n    await this.writer.write(message);\n  }\n\n  async read(cb: (chunk: R) => void) {\n    for await (const chunk of this.readable) {\n      await cb(chunk);\n    }\n  }\n\n  async close() {\n    if (this.writer) {\n      await this.writer.ready;\n      await this.writer.close();\n      this.writer.releaseLock();\n      delete this.writer;\n    } else {\n      this.writable.close();\n    }\n  }\n}\n", "import { TransportStream } from \"./TransportStream.ts\";\nimport { readable, transform } from \"../mod.ts\";\n\nexport class TextTransportStream<\n  W extends string,\n  R extends string,\n> extends TransportStream<W, R> {\n  static encoder = (): TextEncoderStream => new TextEncoderStream();\n  static decoder = (): TextDecoderStream => new TextDecoderStream();\n  static headers = {\n    \"content-type\": \"text/plain\",\n    \"cache-control\": \"no-cache\",\n  };\n}\n\nfunction toUpperCaseStreamHandler(request: Request) {\n  return new Response(\n    request.body!\n      .pipeThrough(TextTransportStream.decoder())\n      .pipeThrough(transform.toUpperCase())\n      .pipeThrough(TextTransportStream.encoder()),\n  );\n}\n\n// @ts-ignore .\nTextTransportStream.demo = async () => {\n  // const ts = new TextTransporter(u);\n\n  // ts.read(console.log);\n  // await ts.write(\"Hello World\");\n\n  for await (\n    const c of readable.of(\"Hello\", \"World\")\n      .pipeThrough(new TextEncoderStream())\n      .pipeThrough(new TransportStream(\"/upper\", toUpperCaseStreamHandler))\n      .pipeThrough(new TextDecoderStream())\n  ) {\n    console.log(c);\n  }\n\n  for await (\n    const c of readable.of(\"Hello\", \"World\")\n      .pipeThrough(\n        new TextTransportStream(\"/uppercase\", toUpperCaseStreamHandler),\n      )\n  ) {\n    console.log(c);\n  }\n\n  // return ts;\n};\n", "// deno-lint-ignore-file no-explicit-any\n\nexport class PairStream<W = any, R = W> {\n  public writable: WritableStream<W>;\n  public readable: ReadableStream<R>;\n\n  private _writer?: WritableStreamDefaultWriter<W>;\n\n  constructor(\n    { writable, readable }: {\n      writable: WritableStream<W>;\n      readable: ReadableStream<R>;\n    } = new TransformStream<W, R>(),\n  ) {\n    this.writable = writable;\n    this.readable = readable;\n  }\n\n  async write(message: W) {\n    this._writer = this._writer || this.writable.getWriter();\n\n    await this._writer.ready;\n    await this._writer.write(message);\n  }\n\n  async read(cb: (chunk: R) => void) {\n    for await (const chunk of this.readable) {\n      await cb(chunk);\n    }\n  }\n\n  async close() {\n    if (this._writer) {\n      await this._writer.ready;\n      await this._writer.close();\n      this._writer.releaseLock();\n      delete this._writer;\n    } else {\n      this.writable.close();\n    }\n  }\n}\n", "export function pipe<\n  R,\n  T extends [TransformStream<R>, ...TransformStream[]],\n>(\n  readable: ReadableStream<R>,\n  ...transforms: T\n): T[-1][\"readable\"] {\n  return transforms.reduce<T[number][\"readable\"]>(\n    (readable, transform) =>\n      readable.pipeThrough<T[number][\"readable\"]>(transform),\n    readable,\n  );\n}\n", "// deno-lint-ignore-file no-explicit-any\nimport { PairStream } from \"./PairStream.ts\";\nimport { isTransformStream } from \"./utils/is.ts\";\nimport { pipe } from \"./pipe.ts\";\n\nexport class PipeStream<\n  I = any,\n  O = any,\n> extends PairStream<I, O> {\n  //\n  declare writer: WritableStreamDefaultWriter<I>;\n  declare reader: ReadableStreamDefaultReader<O>;\n  //\n  declare readable: ReadableStream<O>;\n  declare writable: WritableStream<I>;\n  declare transformers: TransformStream<I, O>[];\n\n  constructor(\n    ...transformers: (TransformStream | Transformer | undefined)[]\n  ) {\n    const { writable, readable } = new TransformStream<I, O>();\n\n    const pipeline = transformers\n      .filter(Boolean)\n      .map((ts) => isTransformStream(ts) ? ts : new TransformStream(ts)) as [\n        TransformStream,\n        ...TransformStream[],\n      ];\n\n    super({\n      readable: pipe(readable, ...pipeline),\n      writable,\n    });\n\n    this.transformers = pipeline;\n  }\n\n  async write(message: I) {\n    this.writer = this.writer || this.writable.getWriter();\n\n    await this.writer.ready;\n    await this.writer.write(message);\n  }\n\n  async read(cb: (chunk: O) => void) {\n    for await (const chunk of this.readable) {\n      await cb(chunk);\n    }\n  }\n}\n", "import { PipeStream } from \"./PipeStream.ts\";\nimport { TransportStream } from \"./TransportStream.ts\";\nimport { STREAM_ID_KEY } from \"./contstants.ts\";\nimport { duplexHandler } from \"./duplexHandler.ts\";\n\nconst EOL = \"\\n\";\n\nexport class JSONEncoderStream<\n  I extends object,\n  O extends string,\n> extends TransformStream<I, O> {\n  constructor() {\n    super({\n      transform(chunk, controller) {\n        try {\n          controller.enqueue(JSON.stringify(chunk) + EOL as O);\n        } catch { /** err */ }\n      },\n    });\n  }\n}\n\nexport class JSONDecoderStream<\n  I extends string = string,\n  O extends object = object,\n> extends TransformStream<I, O> {\n  constructor() {\n    super({\n      transform(chunk, controller) {\n        let runningText = \"\";\n        const objects = chunk.split(EOL);\n        for (const obj of objects) {\n          try {\n            runningText += obj;\n            const result = JSON.parse(runningText);\n            controller.enqueue(result);\n            runningText = \"\";\n          } catch (_e) {\n            // Not a valid JSON object\n          }\n        }\n      },\n    });\n  }\n}\n\nexport class JSONTransportStream extends TransportStream<object, object> {\n  static encoder<I extends object, O extends Uint8Array>(): PipeStream<I, O> {\n    return new PipeStream<I, O>(\n      new JSONEncoderStream(),\n      new TextEncoderStream(),\n    );\n  }\n  static decoder<I extends Uint8Array, O extends object>(): PipeStream<I, O> {\n    return new PipeStream<I, O>(\n      new TextDecoderStream(),\n      new JSONDecoderStream(),\n    );\n  }\n  static headers: HeadersInit = {\n    \"content-type\": \"text/event-stream\",\n    \"cache-control\": \"no-cache\",\n  };\n}\n\nconst jsonStreamHandler = duplexHandler((request) =>\n  new Response(\n    request.body?.pipeThrough(\n      new PipeStream(\n        new TextDecoderStream(),\n        new JSONDecoderStream(),\n        new TransformStream<object, object>({\n          transform(chunk, ctrl) {\n            ctrl.enqueue({\n              ...chunk,\n              url: request.url,\n              id: request.headers.get(STREAM_ID_KEY),\n            });\n          },\n        }),\n        new JSONEncoderStream(),\n        new TextEncoderStream(),\n      ),\n    ),\n  )\n);\n\nconst jsonStreamHandler2 = duplexHandler((request) =>\n  new Response(\n    request.body!\n      .pipeThrough(JSONTransportStream.decoder())\n      .pipeThrough(\n        new TransformStream<object, object>({\n          transform(chunk, ctrl) {\n            ctrl.enqueue({\n              ...chunk,\n              url: request.url,\n              id: request.headers.get(STREAM_ID_KEY)!,\n            });\n          },\n        }),\n      )\n      .pipeThrough(JSONTransportStream.encoder()),\n  )\n);\n\n// @ts-ignore .\nJSONTransportStream.demo = () => {\n  const ts = new JSONTransportStream(\"/json\", jsonStreamHandler2);\n  ts.read(console.log);\n\n  ts.write({ uid: \"serebano\", msg: \"Anybody here?\" });\n\n  return ts;\n};\n", "export * from \"./EventSourceMessage.ts\";\nexport * from \"./EventSourceDecoderStream.ts\";\nexport * from \"./EventSourceEncoderStream.ts\";\n\nimport { parse } from \"./parse.ts\";\nimport { stringify } from \"./stringify.ts\";\n\nexport const ESS = { stringify, parse };\n", "import {\n  EventSourceDecoderStream,\n  EventSourceEncoderStream,\n  type EventSourceMessage,\n} from \"./ess/mod.ts\";\nimport { PipeStream } from \"./PipeStream.ts\";\nimport { TransportStream } from \"./TransportStream.ts\";\nimport { transform } from \"../mod.ts\";\n\nexport * from \"./ess/mod.ts\";\n\nexport class EventSourceTransportStream\n  extends TransportStream<EventSourceMessage, EventSourceMessage> {\n  static encoder = (): PipeStream<EventSourceMessage, Uint8Array> =>\n    new PipeStream<EventSourceMessage, Uint8Array>(\n      new EventSourceEncoderStream(),\n      new TextEncoderStream(),\n    );\n  static decoder = (): PipeStream<Uint8Array, EventSourceMessage> =>\n    new PipeStream<Uint8Array, EventSourceMessage>(\n      new TextDecoderStream(),\n      new EventSourceDecoderStream(),\n    );\n\n  static headers: HeadersInit = {\n    \"content-type\": \"text/event-stream\",\n    \"cache-control\": \"no-cache\",\n  };\n}\n\nexport class EventSourceResponse extends Response {\n  constructor(body: ReadableStream<EventSourceMessage>, init?: ResponseInit) {\n    super(\n      body\n        .pipeThrough(new EventSourceEncoderStream())\n        .pipeThrough(new TextEncoderStream()),\n      init,\n    );\n    this.headers.set(\"content-type\", \"text/event-stream\");\n    this.headers.set(\"cache-control\", \"no-cache\");\n  }\n}\n\nfunction eventSourceStreamHandler(request: Request) {\n  return new Response(\n    request.body!\n      .pipeThrough(EventSourceTransportStream.decoder())\n      .pipeThrough(\n        transform.map((m) => ({\n          ...m,\n          comment: \"Duplexxx\",\n        })),\n      )\n      .pipeThrough(EventSourceTransportStream.encoder()),\n  );\n}\n\n// @ts-ignore .\nEventSourceTransportStream.demo = () => {\n  const ess = new EventSourceTransportStream(\"/ess\", eventSourceStreamHandler);\n\n  ess.read(console.log);\n\n  ess.write({ data: \"hi es\" });\n\n  return ess;\n};\n", "import { PairStream } from \"./PairStream.ts\";\n\nexport class BroadcastStream<\n  W extends Uint8Array,\n  R extends W = W,\n> extends PairStream<W, R> {\n  static debug = true;\n  static weakMap: WeakMap<\n    BroadcastStream<Uint8Array, Uint8Array>,\n    ReadableStreamDefaultController<Uint8Array>\n  > = new WeakMap<\n    BroadcastStream<Uint8Array>,\n    ReadableStreamDefaultController<Uint8Array>\n  >();\n\n  static controllers: Set<ReadableStreamDefaultController<Uint8Array>> =\n    new Set<ReadableStreamDefaultController<Uint8Array>>();\n\n  constructor(\n    public controllers: Set<ReadableStreamDefaultController<R>> =\n      new.target.controllers,\n    writableStrategy?: QueuingStrategy<W>,\n    readableStrategy?: QueuingStrategy<R>,\n  ) {\n    const debug = new.target.debug;\n\n    super();\n\n    this.writable = new WritableStream<W>({\n      start: () => {\n        debug && console.log(new.target.name, \".writable.start()\");\n      },\n      close: () => {\n        debug && console.log(new.target.name, \".writable.close()\");\n      },\n      abort: () => {\n        debug && console.log(new.target.name, \".writable.abort()\");\n      },\n      write: (chunk) => {\n        debug && console.log(\n          new.target.name,\n          \".writable.write()\",\n          this.controllers.size,\n        );\n        this.controllers.forEach((controller) => {\n          controller.enqueue(chunk as R);\n        });\n      },\n    }, writableStrategy);\n\n    this.readable = new ReadableStream<R>({\n      start: (controller) => {\n        debug && console.log(\n          new.target.name,\n          \".readable.start()\",\n          this.controllers.size,\n        );\n\n        new.target.weakMap.set(this, controller);\n        this.controllers.add(controller);\n      },\n      cancel: () => {\n        this.controllers.delete(new.target.weakMap.get(this)!);\n        new.target.weakMap.delete(this);\n\n        debug && console.log(\n          new.target.name,\n          \".readable.cancel()\",\n          this.controllers.size,\n        );\n      },\n      pull() {\n        // console.log(\"[BroadcastStream].readable.pull()\");\n      },\n    }, readableStrategy);\n  }\n}\n", "import { colors, delay } from \"../utils.ts\";\nimport { BroadcastStream } from \"./BroadcastStream.ts\";\nimport { DuplexRequest } from \"./DuplexRequest.ts\";\nimport { TransportStream } from \"./TransportStream.ts\";\nimport { METHOD, STREAM_ID_KEY } from \"./contstants.ts\";\nimport { duplexHandler } from \"./duplexHandler.ts\";\n\nexport type Method =\n  | \"GET\"\n  | \"HEAD\"\n  | \"POST\"\n  | \"PUT\"\n  | \"DELETE\"\n  | \"OPTIONS\"\n  | \"PATCH\"\n  | \"*\";\n\nexport type MethodNames =\n  | \"get\"\n  | \"head\"\n  | \"post\"\n  | \"put\"\n  | \"delete\"\n  | \"options\"\n  | \"patch\"\n  | \"any\";\n\nexport interface Context {\n  body?: string | object | ReadableStream<Uint8Array>;\n  response?: Response;\n  route?: Route;\n  match?: {\n    params: Record<string, string | undefined>;\n    path: string;\n  };\n  url: URL;\n  status: number;\n  headers: Headers;\n  params: Record<string, string | undefined>;\n  method: Method;\n  routes: Route[];\n  base?: Context;\n  duplexId?: string | null;\n  handled: PromiseWithResolvers<Response>;\n}\n\nexport class Context {\n  constructor(init?: Partial<Context>) {\n    Object.assign(this, init);\n  }\n}\n\nexport type HandlerResponse =\n  | Response\n  | ReadableStream\n  | undefined\n  | object\n  | string\n  | null\n  | void;\n\nexport type RouteHandler = (\n  request: Request,\n  context: Context,\n) => HandlerResponse | Promise<HandlerResponse>;\n\nexport type RouterHandler = (\n  request: Request,\n  context?: Context | object,\n) => Response | Promise<Response>;\n\nexport type Handler = RouteHandler | Route | Router;\n\nexport interface RouteInit {\n  method?: Method;\n  path?: string;\n  handler?: Handler;\n}\n\nexport interface RouterMethod {\n  (...handlers: Handler[]): Router;\n  (path: string, ...handlers: Handler[]): Router;\n  (path: string[], ...handlers: Handler[]): Router;\n}\n\nexport interface RouteMethod {\n  (\n    path: string | RouteInit | RouteHandler,\n    init?: RouteInit | RouteHandler,\n  ): Route;\n}\n\nexport class Route {\n  method: Method;\n  path: string;\n\n  pattern: URLPattern;\n  handler: RouteHandler | Router;\n  declare basePath: string;\n\n  static create = (method: METHOD): RouteMethod =>\n  (\n    path: string | RouteInit | RouteHandler,\n    init?: RouteInit | RouteHandler,\n  ) =>\n    path && typeof path !== \"string\"\n      ? new Route(Object.assign(path, { method }))\n      : new Route(path, Object.assign(init || {}, { method }));\n\n  static any: RouteMethod = this.create(METHOD.ANY);\n  static get: RouteMethod = this.create(METHOD.GET);\n  static put: RouteMethod = this.create(METHOD.PUT);\n  static post: RouteMethod = this.create(METHOD.POST);\n  static head: RouteMethod = this.create(METHOD.HEAD);\n  static patch: RouteMethod = this.create(METHOD.PATCH);\n  static delete: RouteMethod = this.create(METHOD.DELETE);\n  static options: RouteMethod = this.create(METHOD.OPTIONS);\n\n  constructor(\n    routeInit?: RouteInit | RouteHandler,\n  );\n  constructor(\n    path?: string,\n    routeInit?: RouteInit | RouteHandler,\n  );\n  constructor(\n    path?: string | RouteInit | RouteHandler,\n    routeInit?: RouteInit | RouteHandler,\n  ) {\n    if (typeof path !== \"undefined\" && typeof path !== \"string\") {\n      routeInit = path;\n      path = undefined;\n    }\n\n    path = path || \"\";\n    routeInit = routeInit || {};\n\n    if (routeInit instanceof Route) {\n      // Route\n      const _routeInit = routeInit;\n      this.basePath = _routeInit.basePath || \"\";\n      const handler = _routeInit.handler instanceof Router\n        ? _routeInit.handler.base(path.replaceAll(\"/*\", \"\"))\n        : _routeInit.handler;\n\n      path = path + _routeInit.path;\n      const method = _routeInit.method || \"*\";\n\n      routeInit = { handler, method };\n      //\n    } else if (routeInit instanceof Router) {\n      // Router\n      const _routeInit = routeInit.base(path);\n      this.basePath = _routeInit.basePath; //path + (routeInit.basePath || \"\");\n      path = this.basePath ? this.basePath + \"/*\" : \"*\";\n      const method = \"*\";\n      routeInit = { handler: _routeInit, method };\n    } else if (typeof routeInit === \"function\") {\n      // Raw Handler Func\n      // @ts-ignore .\n      const method = routeInit.method || \"*\";\n      routeInit = { handler: routeInit, method };\n    }\n\n    routeInit.handler = routeInit.handler || (() => `Handler Placeholder`);\n\n    this.path = path || \"*\";\n    this.method = routeInit?.method || \"*\";\n    this.handler = routeInit.handler as RouteHandler;\n    this.pattern = new URLPattern({ pathname: this.path });\n  }\n\n  base(path?: string): Route {\n    return new Route(path, this);\n  }\n\n  match(request: Request): {\n    params: Record<string, string | undefined>;\n    path: string;\n    route: Route;\n  } | null {\n    const match = (this.method === \"*\" || request.method === this.method) &&\n      this.pattern.exec(request.url);\n\n    return match\n      ? {\n        params: match.pathname.groups,\n        path: match.pathname.input,\n        route: this,\n      }\n      : null;\n  }\n\n  toString(i = \"\"): string {\n    const type = this.handler instanceof Router || this.handler instanceof Route\n      ? this.handler.constructor.name\n      : this.handler?.name ||\n        String(this.handler).split(\"\\n\")[0].replace(\"=> {\", \"=> { ... }\")\n          .replace(\"=>{\", \"=>{...}\");\n\n    const routes = this.handler instanceof Router\n      ? colors.magenta(` [${this.handler.stack.length}]`)\n      : ``;\n    return this.handler instanceof Router || this.handler instanceof Route\n      ? [\n        i,\n        colors.brightBlue(`[${this.method}]`),\n        colors.brightBlue(this.path),\n        \"\",\n        colors.yellow(type + routes),\n      ]\n        .join(\" \") +\n        \"\\n\" +\n        this.handler.toString(i + \"    \")\n      : [\n        i,\n        colors.white(`[${this.method}]`),\n        colors.brightWhite(this.path),\n        \"\",\n        colors.gray(colors.italic(type)),\n      ].join(\n        \" \",\n      );\n  }\n\n  print() {\n    console.log(this.toString());\n  }\n}\n\nexport class Router {\n  Route = Route;\n  Context = Context;\n\n  constructor(public basePath: string = \"\", public stack: Route[] = []) {\n    this.handler = duplexHandler(this.handler.bind(this));\n    this.match = this.match.bind(this);\n    this.base = this.base.bind(this);\n    this.use = this.use.bind(this);\n    this.toString = this.toString.bind(this);\n  }\n\n  async test(path: string): Promise<string> {\n    const res = await this.handler(new DuplexRequest(path));\n    return res.text();\n  }\n\n  base(path?: string): Router {\n    if (path?.includes(\"*\")) {\n      throw new TypeError(`Base path contains invalid characters: ${path}`);\n    }\n\n    const router = new Router(\n      (path || \"\") + this.basePath,\n      this.stack.map((route) => new Route(path, route)),\n    );\n\n    return router;\n  }\n\n  add = (\n    method: METHOD,\n    path: string | string[] | Handler,\n    handlers: Handler[],\n  ): Router => {\n    if (\n      typeof path === \"function\" || path instanceof Route ||\n      path instanceof Router\n    ) {\n      handlers = [path, ...handlers];\n      path = \"\";\n    }\n\n    const paths = (typeof path === \"object\" ? [...path] : [path]).map((p) =>\n      this.basePath + p\n    );\n\n    const prop = method.toLowerCase() as Lowercase<METHOD>;\n    const methodFunc = prop === \"*\" ? Route[\"any\"] : Route[prop];\n\n    for (const path of paths) {\n      for (const handler of handlers) {\n        this.stack.push(methodFunc(path, handler));\n      }\n    }\n\n    return this;\n  };\n\n  create = (method: METHOD): RouterMethod => (path, ...handlers): Router =>\n    this.add(method, path, handlers);\n\n  use: RouterMethod = this.create(METHOD.ANY);\n  any: RouterMethod = this.create(METHOD.ANY);\n  get: RouterMethod = this.create(METHOD.GET);\n  put: RouterMethod = this.create(METHOD.PUT);\n  post: RouterMethod = this.create(METHOD.POST);\n  head: RouterMethod = this.create(METHOD.HEAD);\n  patch: RouterMethod = this.create(METHOD.PATCH);\n  delete: RouterMethod = this.create(METHOD.DELETE);\n  options: RouterMethod = this.create(METHOD.OPTIONS);\n\n  handler(\n    request: Request,\n  ): Promise<Response>;\n\n  handler(\n    request: Request,\n    baseContext: Context,\n  ): Promise<Response | undefined>;\n\n  handler(\n    request: Request,\n    baseContext?: object,\n  ): Promise<Response>;\n\n  async handler(\n    request: Request,\n    baseContext?: Context | object,\n  ): Promise<Response | undefined> {\n    const hasBase = baseContext instanceof Context;\n    const context = this.createContext(request, baseContext);\n\n    try {\n      const response = await handle(request, context, this.stack);\n      if (response instanceof Response) {\n        context.handled.resolve(response);\n\n        return response;\n      }\n\n      if (!hasBase) {\n        return new Response(`404 - Unhandled Request`, { status: 404 });\n      }\n    } catch (e) {\n      context.handled.reject(e);\n\n      return new Response(`500 - ${e.message}`, { status: 500 });\n    }\n  }\n\n  createContext(request: Request, context?: Context | object): Context {\n    if (context instanceof Context) {\n      return context;\n    }\n\n    return new Context({\n      url: new URL(request.url),\n      method: request.method as Method,\n      duplexId: request.headers.get(STREAM_ID_KEY),\n      headers: new Headers(),\n      status: 200,\n      params: {},\n      routes: [],\n      handled: Promise.withResolvers<Response>(),\n    });\n  }\n\n  async handleEvent(event: FetchEvent): Promise<Response | undefined> {\n    const context = this.createContext(event.request);\n    const response = await this.handler(event.request, context);\n    if (response) {\n      event.respondWith(response);\n    }\n\n    return response;\n  }\n\n  match(\n    request: Request,\n  ): (\n    | { params: Record<string, string | undefined>; path: string; route: Route }\n    | null\n  )[] {\n    return this.stack.map((route) => route.match(request));\n  }\n\n  toString(i = \"\"): string {\n    return this.stack.map((route) => route.toString(i)).join(\"\\n\");\n  }\n\n  print() {\n    console.log(this.toString());\n  }\n}\n\nasync function handle(request: Request, context: Context, stack: Route[]) {\n  for (const layer of stack) {\n    const match = layer.match(request);\n    if (match) {\n      context.params = match.params;\n      context.route = layer;\n\n      const handler = layer.handler instanceof Router\n        ? layer.handler.handler!\n        : layer.handler!;\n\n      const result = await handler(request, context);\n\n      if (typeof result === \"undefined\") {\n        continue;\n      }\n\n      if (result instanceof Response) {\n        return result;\n      }\n\n      const responseInit = {\n        status: context.status,\n        headers: context.headers,\n      };\n\n      if (\n        (result instanceof ReadableStream) ||\n        typeof result === \"string\" ||\n        result === null\n      ) {\n        return new Response(result, responseInit);\n      }\n\n      if (typeof result === \"object\") {\n        return Response.json(result, responseInit);\n      }\n    }\n  }\n}\n\nroute.Route = Route;\nroute.Router = Router;\nroute.Context = Context;\n\nexport function route(\n  path: string | Handler,\n  ...handlers: Handler[]\n): Router {\n  if (typeof path !== \"string\") {\n    handlers = [path, ...handlers];\n    path = \"\";\n  }\n  return new Router(path).use(...handlers);\n}\n\nroute.test = async (): Promise<Router> => {\n  const app = new Router();\n  app.use(\"*\", route.cors(), route.logger());\n  app.use(\"/\", () => \"Home Page\");\n  app.use(\"/delay\", () => delay(3000).then(() => \"Done\"));\n  app.use(\"/about\", () => \"About Page\");\n  app.use(\"/echo\", route.broadcastHandler);\n\n  const blog = new Router(\"/ipress\");\n  blog.use(\"/\", () => \"Blog Home\");\n  blog.use(\"/post/:id\", (_, ctx) => `Blog Post #${ctx.params.id}`);\n\n  app.use(blog.base(\"/blog1\"));\n  app.use(\"/blog2\", blog);\n\n  app.use(\"/test\", (_) => `Testtst`);\n\n  const x = route(\"\").use(\"/\", () => \"hi\");\n  const a = x.base(\"/a\");\n  const b = x.base(\"/b\");\n  const c = x.base(\"/c\").use(\"/*\", () => \"xxc\");\n\n  app.use(a.use(b.use(c)));\n\n  const request = new Request(\"https://localhost/blog1/ipress/\");\n\n  const result = await (await app.handler(request)).text();\n  console.log(result);\n  console.log(app.toString());\n\n  Object.assign(globalThis, { app, blog, route });\n  if (typeof Deno !== \"undefined\") {\n    const server = route.serve(app);\n\n    console.log(server);\n  }\n  return app;\n};\n\nroute.serve = (\n  handler: RouterHandler | Router,\n): {} =>\n  Deno.serve({\n    port: 8001,\n    key: Deno.env.get(\"KEY\"),\n    cert: Deno.env.get(\"CERT\"),\n  }, handler instanceof Router ? handler.handler : handler);\n\nroute.handler = (h: Handler): Handler => h;\n\nroute.cors = (): Handler =>\n  route.handler((_req, ctx) => {\n    ctx.headers.set(\"cache-control\", \"no-cache\");\n    ctx.headers.set(\"access-control-allow-origin\", \"*\");\n    ctx.headers.set(\"access-control-allow-methods\", \"*\");\n    ctx.headers.set(\"access-control-allow-headers\", \"*\");\n    ctx.headers.set(\"access-control-max-age\", \"100\");\n    if (_req.method === \"OPTIONS\") {\n      return new Response(null, ctx);\n    }\n  });\n\nroute.broadcastHandler = (): Router =>\n  route(\n    route.cors(),\n    (_, ctx) => {\n      ctx.headers.set(\"content-type\", \"text/event-stream\");\n    },\n    function broadcastStream(req) {\n      const stream = new BroadcastStream();\n      req.body?.pipeTo(stream.writable);\n\n      return stream.readable;\n    },\n  );\n\n// route.broadcastStdIO = () => {\n//   const stream = new TransportStream(\"https://localhost:8001/echo/\");\n\n//   Deno.stdin.readable.pipeTo(stream.writable);\n//   stream.readable.pipeTo(Deno.stdout.writable);\n// };\n\nroute.notFound = (): Handler =>\n  route.handler((req) =>\n    new Response(`404 - Not Found\\n${req.method} ${req.url}`, { status: 404 })\n  );\n\nroute.logger = (tag: string = \"\"): Handler =>\n  route.handler((req, ctx) => {\n    console.log(\n      `${colors.dim(tag)} ${ctx.base ? \"----\" : \"--\"} >> [${\n        colors.blue(req.method)\n      }] ${colors.dim(req.url)} ${\n        ctx.duplexId ? colors.bgWhite(ctx.duplexId) : \"\"\n      }`,\n    );\n\n    ctx.handled.promise.then((response) => {\n      console.log(\n        `${colors.dim(tag)} << ${ctx.base ? \"----\" : \"--\"} [${\n          colors.yellow(req.method)\n        }] ${colors.dim(req.url)}`,\n        response.headers,\n      );\n    });\n  });\n\nroute.test();\n\n// export function handle(\n//   request: Request,\n//   baseCtx: Context | undefined,\n//   routes: Route[],\n// ): Promise<Response> {\n//   // create context\n\n//   const context = new Context({\n//     base: baseCtx instanceof Context ? baseCtx : undefined,\n//     url: new URL(request.url),\n//     method: request.method as Method,\n//     duplexId: request.headers.get(STREAM_ID_KEY),\n//     headers: new Headers(baseCtx?.headers),\n//     status: baseCtx?.status || 200,\n//     params: {},\n//     routes: [],\n//     handled: Promise.withResolvers<Response>(),\n//   });\n\n//   async function res() {\n//     // find matched routes\n//     for (const layer of routes) {\n//       const match = layer.match(request);\n//       //  (layer.method === \"*\" || request.method === layer.method) &&\n//       //   layer.pattern.exec(request.url);\n\n//       if (match) {\n//         context.routes.push(layer);\n//         context.route = layer;\n//         context.match = match;\n//         context.params = match.params;\n\n//         const result = await layer.handler(request, context);\n//         if (typeof result === \"undefined\") continue;\n\n//         const responseInit = {\n//           status: context.status,\n//           headers: context.headers,\n//         };\n\n//         if (result instanceof Response) {\n//           return result;\n//         }\n\n//         if (\n//           (result instanceof ReadableStream) ||\n//           typeof result === \"string\" ||\n//           result === null\n//         ) {\n//           return new Response(result, responseInit);\n//         }\n\n//         if (typeof result === \"object\") {\n//           return Response.json(result, responseInit);\n//         }\n//       }\n//     }\n\n//     return new Response(`404 - Unhandled Request`, { status: 404 });\n//   }\n\n//   return res()\n//     .then((res) => {\n//       context.handled.resolve(res);\n//       return context.handled.promise;\n//     }).then((res) => {\n//       if (context.base) {\n//         context.base.handled.resolve(res);\n//         return context.base.handled.promise;\n//       }\n//       return res;\n//     });\n// }\n", "export * from \"./Promised.ts\";\nexport * from \"./pipeTo.ts\";\nexport * from \"./path.ts\";\nexport * from \"./is.ts\";\n", "export const pipeTo = <T extends Uint8Array>(\n  destination: WritableStream<T> | TransformStream<T, T>,\n): (source: ReadableStream<T> | Response | Request) => Promise<void> =>\n(source: ReadableStream<T> | Response | Request) =>\n  source instanceof ReadableStream\n    ? source.pipeTo(\n      destination instanceof WritableStream\n        ? destination\n        : destination.writable,\n    )\n    : source.body!.pipeTo(\n      destination instanceof WritableStream\n        ? destination\n        : destination.writable,\n    );\n", "export const mergePath = (...paths: string[]): string => {\n  let p: string = \"\";\n  let endsWithSlash = false;\n\n  for (let path of paths) {\n    /* ['/hey/','/say'] => ['/hey', '/say'] */\n    if (p[p.length - 1] === \"/\") {\n      p = p.slice(0, -1);\n      endsWithSlash = true;\n    }\n\n    /* ['/hey','say'] => ['/hey', '/say'] */\n    if (path[0] !== \"/\") {\n      path = `/${path}`;\n    }\n\n    /* ['/hey/', '/'] => `/hey/` */\n    if (path === \"/\" && endsWithSlash) {\n      p = `${p}/`;\n    } else if (path !== \"/\") {\n      p = `${p}${path}`;\n    }\n\n    /* ['/', '/'] => `/` */\n    if (path === \"/\" && p === \"\") {\n      p = \"/\";\n    }\n  }\n\n  return p;\n};\n", "{\n  \"name\": \"@clappcodes/transporter\",\n  \"version\": \"0.3.5\",\n  \"exports\": \"./mod.ts\",\n  \"tasks\": {\n    \"dev\": \"DEBUG=false deno run -A --inspect --env --watch main.ts\",\n    \"run\": \"deno run -A --watch --env --inspect=127.0.0.1:9229 run.ts\",\n    \"serve\": \"deno run -A --env --watch --inspect=127.0.0.1:9230 serve.ts\",\n    \"bundle\": \"deno run -A ./.tools/bundle.ts\",\n    \"npm:build\": \"deno run -A ./.tools/npm.build.ts\",\n    \"npm:publish\": \"deno run -A ./.tools/npm.publish.ts\",\n    \"safe\": \"deno fmt mod.ts && deno lint mod.ts && deno check mod.ts\",\n    \"pub\": \"deno task safe && deno task bundle && deno task npm:publish && deno publish --allow-dirty\",\n    \"deploy\": \"deno task safe && deno task bundle && deployctl deploy --prod\",\n    \"install\": \"deno install -f -A --name serve --env serve.ts --\"\n  },\n  \"exclude\": [\n    \".npm\",\n    \".bundle\"\n  ],\n  \"compilerOptions\": {\n    \"lib\": [\n      \"deno.window\",\n      \"webworker\",\n      \"dom\"\n    ]\n  },\n  \"deploy\": {\n    \"project\": \"98ab1ab7-5378-473f-9ac8-12d09564c492\",\n    \"name\": \"transporter\",\n    \"exclude\": [\n      \"**/node_modules\",\n      \".npm\"\n    ],\n    \"include\": [],\n    \"entrypoint\": \"main.ts\"\n  }\n}", "import { bold, gray, yellow } from \"./colors.ts\";\nimport * as transporter from \"./mod.ts\";\nimport pkg from \"./deno.json\" with { type: \"json\" };\n\nObject.assign(globalThis, { transporter }, transporter);\n\n// if (\"serviceWorker\" in navigator) {\n//   navigator.serviceWorker.register(\"/sw.ts\");\n// }\n\nif (typeof document !== \"undefined\") {\n  fetch(\"/transporter.txt\").then((res) => res.text()).then((res) => {\n    console.log(bold(gray(res)));\n    Object.assign(globalThis, {\n      TransporterLogo: res,\n    });\n  });\n}\n\nconsole.log(\n  \"\\n\\t\" +\n    bold(yellow(pkg.name)) + \" \" +\n    gray(pkg.version) + \"\\n\\n\",\n);\n\ndeclare global {\n  const readable: typeof transporter.readable;\n  const writable: typeof transporter.writable;\n  const transform: typeof transporter.transform;\n}\n\nexport {};\n"],
  "mappings": "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",
  "names": ["Deno", "code", "mod_exports", "pipe", "mod_exports", "readable", "fn", "mod_exports", "mod_exports", "alphaMap", "isTransformStream", "transform", "isTransformStream", "mapper", "fd", "encoder", "to", "reset", "transform", "isTransformStream", "map", "fetch", "fetch", "mod_exports", "readable", "pipe", "readable", "transform", "readable", "isTransformStream", "pipe", "mod_exports", "route", "path", "x", "mod_exports", "isTransformStream", "mod_exports"]
}
