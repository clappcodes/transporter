{
  "version": 3,
  "sources": ["../colors.ts", "../mod.ts", "../utils/is-plain-object.ts", "../readable/from.ts", "../shims.ts", "../readable/mod.ts", "../readable/from-body.ts", "../readable/from-fetch.ts", "../readable/from-timer.ts", "../readable/external.ts", "../readable/from-event.ts", "../readable/from-iterable.ts", "../readable/from-generator.ts", "../readable/just.ts", "../readable/range.ts", "../readable/read.ts", "../readable/consume.ts", "../writable/mod.ts", "../writable/subscribe.ts", "../writable/post.ts", "../writable/write.ts", "../transform/mod.ts", "../transform/each.ts", "../transform/lower-case.ts", "../transform/map.ts", "../utils.ts", "../app/echo2.ts", "../utils/Promised.ts", "../app/echo1.ts", "../app/defineStreamHandler.ts", "../transform/pipe.ts", "../transform/tap.ts", "../transform/text.ts", "../transform/upper-case.ts", "../transform/log.ts", "../transform/to.ts", "../transform/to-uint8array.ts", "../transform/debounce.ts", "../transform/filter.ts", "../transform/check.ts", "../transform/apply.ts", "../transport/pipe.ts", "../transport/PipeStream.ts", "../transport/ess/parser.ts", "../transport/ess/parse.ts", "../transport/ess/stringify.ts", "../transport/ess/EventSourceMessage.ts", "../transport/ess/EventSourceDecoderStream.ts", "../transport/ess/EventSourceEncoderStream.ts", "../transform/sse.ts", "../transport/mod.ts", "../transport/RoutesInit.ts", "../transport/handle.ts", "../transport/RequestDuplex.ts", "../playground/useCors.ts", "../transport/fetchDuplex.ts", "../transport/pipeTo.ts", "../transport/Transporter.ts", "../transport/JSONTransporter.ts", "../transport/RequestStream.ts", "../transport/TextTransporter.ts", "../transport/ess/mod.ts", "../transport/ess/EventSourceStream.ts", "../transport/ess/ESS.ts", "../transport/EventSourceTransporter.ts", "../transport/TextTransportStream.ts", "../transport/TransportStream.ts", "../utils/app.ts", "../transport/app/Route.ts", "../transport/app/Router.ts", "../transport/app/App.ts", "../transport/app/Methods.ts", "../deno.json", "../playground/pipe1.ts", "../global.ts"],
  "sourcesContent": ["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n// A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors\n// on npm.\n\n/**\n * String formatters and utilities for dealing with ANSI color codes.\n *\n * This module is browser compatible.\n *\n * This module supports `NO_COLOR` environmental variable disabling any coloring\n * if `NO_COLOR` is set.\n *\n * @example\n * ```ts\n * import {\n *   bgBlue,\n *   bgRgb24,\n *   bgRgb8,\n *   bold,\n *   italic,\n *   red,\n *   rgb24,\n *   rgb8,\n * } from \"@std/fmt/colors\";\n *\n * console.log(bgBlue(italic(red(bold(\"Hello, World!\")))));\n *\n * // also supports 8bit colors\n *\n * console.log(rgb8(\"Hello, World!\", 42));\n *\n * console.log(bgRgb8(\"Hello, World!\", 42));\n *\n * // and 24bit rgb\n *\n * console.log(rgb24(\"Hello, World!\", {\n *   r: 41,\n *   g: 42,\n *   b: 43,\n * }));\n *\n * console.log(bgRgb24(\"Hello, World!\", {\n *   r: 41,\n *   g: 42,\n *   b: 43,\n * }));\n * ```\n *\n * @module\n */\n\n// deno-lint-ignore no-explicit-any\nconst { Deno } = globalThis as any;\nconst noColor = typeof Deno?.noColor === \"boolean\"\n  ? Deno.noColor as boolean\n  : false;\n\ninterface Code {\n  open: string;\n  close: string;\n  regexp: RegExp;\n}\n\n/** RGB 8-bits per channel. Each in range `0->255` or `0x00->0xff` */\nexport interface Rgb {\n  /** Red component value */\n  r: number;\n  /** Green component value */\n  g: number;\n  /** Blue component value */\n  b: number;\n}\n\nlet enabled = !noColor;\n\n/**\n * Set changing text color to enabled or disabled\n * @param value\n */\nexport function setColorEnabled(value: boolean) {\n  if (Deno?.noColor) {\n    return;\n  }\n\n  enabled = value;\n}\n\n/** Get whether text color change is enabled or disabled. */\nexport function getColorEnabled(): boolean {\n  return enabled;\n}\n\n/**\n * Builds color code\n * @param open\n * @param close\n */\nfunction code(open: number[], close: number): Code {\n  return {\n    open: `\\x1b[${open.join(\";\")}m`,\n    close: `\\x1b[${close}m`,\n    regexp: new RegExp(`\\\\x1b\\\\[${close}m`, \"g\"),\n  };\n}\n\n/**\n * Applies color and background based on color code and its associated text\n * @param str text to apply color settings to\n * @param code color code to apply\n */\nfunction run(str: string, code: Code): string {\n  return enabled\n    ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`\n    : str;\n}\n\n/**\n * Reset the text modified.\n * @param str text to reset\n */\nexport function reset(str: string): string {\n  return run(str, code([0], 0));\n}\n\n/**\n * Make the text bold.\n * @param str text to make bold\n */\nexport function bold(str: string): string {\n  return run(str, code([1], 22));\n}\n\n/**\n * The text emits only a small amount of light.\n * @param str text to dim\n *\n * Warning: Not all terminal emulators support `dim`.\n * For compatibility across all terminals, use {@linkcode gray} or {@linkcode brightBlack} instead.\n */\nexport function dim(str: string): string {\n  return run(str, code([2], 22));\n}\n\n/**\n * Make the text italic.\n * @param str text to make italic\n */\nexport function italic(str: string): string {\n  return run(str, code([3], 23));\n}\n\n/**\n * Make the text underline.\n * @param str text to underline\n */\nexport function underline(str: string): string {\n  return run(str, code([4], 24));\n}\n\n/**\n * Invert background color and text color.\n * @param str text to invert its color\n */\nexport function inverse(str: string): string {\n  return run(str, code([7], 27));\n}\n\n/**\n * Make the text hidden.\n * @param str text to hide\n */\nexport function hidden(str: string): string {\n  return run(str, code([8], 28));\n}\n\n/**\n * Put horizontal line through the center of the text.\n * @param str text to strike through\n */\nexport function strikethrough(str: string): string {\n  return run(str, code([9], 29));\n}\n\n/**\n * Set text color to black.\n * @param str text to make black\n */\nexport function black(str: string): string {\n  return run(str, code([30], 39));\n}\n\n/**\n * Set text color to red.\n * @param str text to make red\n */\nexport function red(str: string): string {\n  return run(str, code([31], 39));\n}\n\n/**\n * Set text color to green.\n * @param str text to make green\n */\nexport function green(str: string): string {\n  return run(str, code([32], 39));\n}\n\n/**\n * Set text color to yellow.\n * @param str text to make yellow\n */\nexport function yellow(str: string): string {\n  return run(str, code([33], 39));\n}\n\n/**\n * Set text color to blue.\n * @param str text to make blue\n */\nexport function blue(str: string): string {\n  return run(str, code([34], 39));\n}\n\n/**\n * Set text color to magenta.\n * @param str text to make magenta\n */\nexport function magenta(str: string): string {\n  return run(str, code([35], 39));\n}\n\n/**\n * Set text color to cyan.\n * @param str text to make cyan\n */\nexport function cyan(str: string): string {\n  return run(str, code([36], 39));\n}\n\n/**\n * Set text color to white.\n * @param str text to make white\n */\nexport function white(str: string): string {\n  return run(str, code([37], 39));\n}\n\n/**\n * Set text color to gray.\n * @param str text to make gray\n */\nexport function gray(str: string): string {\n  return brightBlack(str);\n}\n\n/**\n * Set text color to bright black.\n * @param str text to make bright-black\n */\nexport function brightBlack(str: string): string {\n  return run(str, code([90], 39));\n}\n\n/**\n * Set text color to bright red.\n * @param str text to make bright-red\n */\nexport function brightRed(str: string): string {\n  return run(str, code([91], 39));\n}\n\n/**\n * Set text color to bright green.\n * @param str text to make bright-green\n */\nexport function brightGreen(str: string): string {\n  return run(str, code([92], 39));\n}\n\n/**\n * Set text color to bright yellow.\n * @param str text to make bright-yellow\n */\nexport function brightYellow(str: string): string {\n  return run(str, code([93], 39));\n}\n\n/**\n * Set text color to bright blue.\n * @param str text to make bright-blue\n */\nexport function brightBlue(str: string): string {\n  return run(str, code([94], 39));\n}\n\n/**\n * Set text color to bright magenta.\n * @param str text to make bright-magenta\n */\nexport function brightMagenta(str: string): string {\n  return run(str, code([95], 39));\n}\n\n/**\n * Set text color to bright cyan.\n * @param str text to make bright-cyan\n */\nexport function brightCyan(str: string): string {\n  return run(str, code([96], 39));\n}\n\n/**\n * Set text color to bright white.\n * @param str text to make bright-white\n */\nexport function brightWhite(str: string): string {\n  return run(str, code([97], 39));\n}\n\n/**\n * Set background color to black.\n * @param str text to make its background black\n */\nexport function bgBlack(str: string): string {\n  return run(str, code([40], 49));\n}\n\n/**\n * Set background color to red.\n * @param str text to make its background red\n */\nexport function bgRed(str: string): string {\n  return run(str, code([41], 49));\n}\n\n/**\n * Set background color to green.\n * @param str text to make its background green\n */\nexport function bgGreen(str: string): string {\n  return run(str, code([42], 49));\n}\n\n/**\n * Set background color to yellow.\n * @param str text to make its background yellow\n */\nexport function bgYellow(str: string): string {\n  return run(str, code([43], 49));\n}\n\n/**\n * Set background color to blue.\n * @param str text to make its background blue\n */\nexport function bgBlue(str: string): string {\n  return run(str, code([44], 49));\n}\n\n/**\n *  Set background color to magenta.\n * @param str text to make its background magenta\n */\nexport function bgMagenta(str: string): string {\n  return run(str, code([45], 49));\n}\n\n/**\n * Set background color to cyan.\n * @param str text to make its background cyan\n */\nexport function bgCyan(str: string): string {\n  return run(str, code([46], 49));\n}\n\n/**\n * Set background color to white.\n * @param str text to make its background white\n */\nexport function bgWhite(str: string): string {\n  return run(str, code([47], 49));\n}\n\n/**\n * Set background color to bright black.\n * @param str text to make its background bright-black\n */\nexport function bgBrightBlack(str: string): string {\n  return run(str, code([100], 49));\n}\n\n/**\n * Set background color to bright red.\n * @param str text to make its background bright-red\n */\nexport function bgBrightRed(str: string): string {\n  return run(str, code([101], 49));\n}\n\n/**\n * Set background color to bright green.\n * @param str text to make its background bright-green\n */\nexport function bgBrightGreen(str: string): string {\n  return run(str, code([102], 49));\n}\n\n/**\n * Set background color to bright yellow.\n * @param str text to make its background bright-yellow\n */\nexport function bgBrightYellow(str: string): string {\n  return run(str, code([103], 49));\n}\n\n/**\n * Set background color to bright blue.\n * @param str text to make its background bright-blue\n */\nexport function bgBrightBlue(str: string): string {\n  return run(str, code([104], 49));\n}\n\n/**\n * Set background color to bright magenta.\n * @param str text to make its background bright-magenta\n */\nexport function bgBrightMagenta(str: string): string {\n  return run(str, code([105], 49));\n}\n\n/**\n * Set background color to bright cyan.\n * @param str text to make its background bright-cyan\n */\nexport function bgBrightCyan(str: string): string {\n  return run(str, code([106], 49));\n}\n\n/**\n * Set background color to bright white.\n * @param str text to make its background bright-white\n */\nexport function bgBrightWhite(str: string): string {\n  return run(str, code([107], 49));\n}\n\n/* Special Color Sequences */\n\n/**\n * Clam and truncate color codes\n * @param n\n * @param max number to truncate to\n * @param min number to truncate from\n */\nfunction clampAndTruncate(n: number, max = 255, min = 0): number {\n  return Math.trunc(Math.max(Math.min(n, max), min));\n}\n\n/**\n * Set text color using paletted 8bit colors.\n * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit\n * @param str text color to apply paletted 8bit colors to\n * @param color code\n */\nexport function rgb8(str: string, color: number): string {\n  return run(str, code([38, 5, clampAndTruncate(color)], 39));\n}\n\n/**\n * Set background color using paletted 8bit colors.\n * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit\n * @param str text color to apply paletted 8bit background colors to\n * @param color code\n */\nexport function bgRgb8(str: string, color: number): string {\n  return run(str, code([48, 5, clampAndTruncate(color)], 49));\n}\n\n/**\n * Set text color using 24bit rgb.\n * `color` can be a number in range `0x000000` to `0xffffff` or\n * an `Rgb`.\n *\n * To produce the color magenta:\n *\n * ```ts\n * import { rgb24 } from \"@std/fmt/colors\";\n *\n * rgb24(\"foo\", 0xff00ff);\n * rgb24(\"foo\", {r: 255, g: 0, b: 255});\n * ```\n * @param str text color to apply 24bit rgb to\n * @param color code\n */\nexport function rgb24(str: string, color: number | Rgb): string {\n  if (typeof color === \"number\") {\n    return run(\n      str,\n      code(\n        [38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff],\n        39,\n      ),\n    );\n  }\n  return run(\n    str,\n    code(\n      [\n        38,\n        2,\n        clampAndTruncate(color.r),\n        clampAndTruncate(color.g),\n        clampAndTruncate(color.b),\n      ],\n      39,\n    ),\n  );\n}\n\n/**\n * Set background color using 24bit rgb.\n * `color` can be a number in range `0x000000` to `0xffffff` or\n * an `Rgb`.\n *\n * To produce the color magenta:\n *\n * ```ts\n * import { bgRgb24 } from \"@std/fmt/colors\";\n *\n * bgRgb24(\"foo\", 0xff00ff);\n * bgRgb24(\"foo\", {r: 255, g: 0, b: 255});\n * ```\n * @param str text color to apply 24bit rgb to\n * @param color code\n */\nexport function bgRgb24(str: string, color: number | Rgb): string {\n  if (typeof color === \"number\") {\n    return run(\n      str,\n      code(\n        [48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff],\n        49,\n      ),\n    );\n  }\n  return run(\n    str,\n    code(\n      [\n        48,\n        2,\n        clampAndTruncate(color.r),\n        clampAndTruncate(color.g),\n        clampAndTruncate(color.b),\n      ],\n      49,\n    ),\n  );\n}\n\n// https://github.com/chalk/ansi-regex/blob/02fa893d619d3da85411acc8fd4e2eea0e95a9d9/index.js\nconst ANSI_PATTERN = new RegExp(\n  [\n    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TXZcf-nq-uy=><~]))\",\n  ].join(\"|\"),\n  \"g\",\n);\n\n/**\n * Remove ANSI escape codes from the string.\n * @param string to remove ANSI escape codes from\n *\n *  @deprecated (will be removed in 1.0.0) Use {@linkcode stripAnsiCode} instead.\n */\nexport function stripColor(string: string): string {\n  return stripAnsiCode(string);\n}\n\n/**\n * Remove ANSI escape codes from the string.\n *\n * @param string to remove ANSI escape codes from\n */\nexport function stripAnsiCode(string: string): string {\n  return string.replace(ANSI_PATTERN, \"\");\n}\n", "// shims\nimport \"./shims.ts\";\n\n// funcs\n// export * from \"./readable/mod.ts\";\n// export * from \"./writeable/mod.ts\";\n// export * from \"./transform/mod.ts\";\n\nexport * as readable from \"./readable/mod.ts\";\nexport * as writable from \"./writable/mod.ts\";\nexport * as transform from \"./transform/mod.ts\";\nexport * as transport from \"./transport/mod.ts\";\n\nexport * as utils from \"./utils.ts\";\n\n// types\nexport type * from \"./types.ts\";\n\nexport { default as package } from \"./deno.json\" with { type: \"json\" };\n", "/**\nCheck if a value is a plain object.\n\nAn object is plain if it's created by either `{}`, `new Object()`, or `Object.create(null)`.\n\n@example\n```\nimport isPlainObject from 'is-plain-obj';\nimport {runInNewContext} from 'node:vm';\n\nisPlainObject({foo: 'bar'});\n//=> true\n\nisPlainObject(new Object());\n//=> true\n\nisPlainObject(Object.create(null));\n//=> true\n\n// This works across realms\nisPlainObject(runInNewContext('({})'));\n//=> true\n\nisPlainObject([1, 2, 3]);\n//=> false\n\nclass Unicorn {}\nisPlainObject(new Unicorn());\n//=> false\n\nisPlainObject(Math);\n//=> false\n```\n*/\nexport default function isPlainObject<Value>(\n  value: unknown,\n): value is Record<PropertyKey, Value>;\n\nexport default function isPlainObject<Value>(\n  value: unknown,\n): value is Record<PropertyKey, Value> {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return (prototype === null || prototype === Object.prototype ||\n    Object.getPrototypeOf(prototype) === null) &&\n    !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n", "// deno-lint-ignore-file no-explicit-any\nimport isPlainObject from \"../utils/is-plain-object.ts\";\n\ntype GeneratorFunc<T> = () => IterableIterator<T>;\ntype AsyncGeneratorFunc<T> = () => AsyncIterableIterator<T>;\n\ntype FromObject<T> = [string, T][]; // { [s: string]: T; } | ArrayLike<T>\n\ntype FromType<T> =\n  | AsyncIterable<T>\n  | Iterable<T>\n  | GeneratorFunc<T>\n  | AsyncGeneratorFunc<T>\n  | ReadableStream<T>\n  | TransformStream<T, T>;\n\ntype FromIterable<T> =\n  | AsyncIterable<T>\n  | Iterable<T>\n  | GeneratorFunc<T>\n  | AsyncGeneratorFunc<T>\n  | ReadableStream<T>;\n\n// function isFoo<T extends Record<string, never>>(obj: T): obj is T {\n//   return (obj as T).foo !== undefined;\n// }\n\nconst isTransformStream = (input: object): input is TransformStream =>\n  (input instanceof TransformStream) ||\n  (\"readable\" in input && \"writable\" in input);\n\nexport function from<R>(\n  input: FromType<R>,\n): ReadableStream<R> {\n  if (isTransformStream(input)) {\n    return input.readable;\n  }\n\n  return readableFromIterable(input);\n}\n\nexport const of = <T extends unknown[]>(...args: T) =>\n  from(args as T[number][]);\n\nexport function readableFromIterable<T>(iterable: FromIterable<T>) {\n  if (typeof iterable === \"function\") {\n    iterable = iterable();\n  }\n\n  return new ReadableStream<T>({\n    async pull(controller) {\n      for await (const chunk of iterable) {\n        controller.enqueue(await chunk);\n      }\n      controller.close();\n    },\n  });\n}\n\nexport function readableFromObject<T>(input: T) {\n  if (isPlainObject(input)) {\n    const str = JSON.stringify(input, null, 2);\n    const lines = str.split(\"\\n\");\n    return readableFromIterable(lines);\n  }\n\n  console.log(\"readableFromObject\", input);\n  throw new TypeError(`Invalid input type: ${typeof input}`);\n}\n\n// const foo = from([1, \"a\"]);\n// const bar = from(new Blob().stream());\n// const baz = from(Object.entries({a:1,b:2,c:'dd'}));\n", "import { from } from \"./readable/from.ts\";\n\nexport async function* ReadableStreamIterator<R>(this: ReadableStream<R>) {\n  const reader = this.getReader();\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nif (!(\"from\" in ReadableStream)) {\n  console.log(\"(shim) ReadableStream.from\");\n  Object.defineProperty(ReadableStream, \"from\", {\n    value: from,\n  });\n}\n\nif (typeof ReadableStream.prototype[Symbol.asyncIterator] === \"undefined\") {\n  console.log(\"(shim) ReadableStream.prototype[Symbol.asyncIterator]\");\n  Object.defineProperty(ReadableStream.prototype, Symbol.asyncIterator, {\n    value: ReadableStreamIterator,\n  });\n}\n", "export * from \"./from-body.ts\";\nexport * from \"./from-fetch.ts\";\nexport * from \"./from.ts\";\nexport * from \"./from-timer.ts\";\nexport * from \"./external.ts\";\nexport * from \"./from-event.ts\";\nexport * from \"./from-generator.ts\";\nexport * from \"./from-iterable.ts\";\nexport * from \"./just.ts\";\nexport * from \"./range.ts\";\nexport * from \"./read.ts\";\nexport * from \"./consume.ts\";\n\nexport function readable<T>(\n  start:\n    | ((controller: ReadableStreamDefaultController<T>) => void)\n    | undefined,\n  rest?: Omit<UnderlyingDefaultSource<T>, \"start\">,\n) {\n  return new ReadableStream<T>({\n    start,\n    ...rest,\n  });\n}\n", "import { readable, transform } from \"../mod.ts\";\n\n/**\n * Retrieves the body of a request or response as a ReadableStream.\n * If the body is already a ReadableStream, it is returned as is.\n * Otherwise, a TypeError is thrown.\n *\n * @param input - The request or response object.\n * @returns The body as a ReadableStream.\n * @throws {TypeError} If the body is not a ReadableStream.\n */\nexport function fromBody(\n  input: Request | Response,\n): ReadableStream<string> {\n  const isRequest = input instanceof Request;\n  const isResponse = input instanceof Response;\n\n  if (isRequest || isResponse) {\n    if (input.body) {\n      return readable.from(input.body)\n        .pipeThrough(transform.decode());\n    }\n  }\n\n  throw new TypeError(`Invalid body type: ${typeof input.body}`);\n}\n", "import { fromBody } from \"./from-body.ts\";\n\nexport async function fromFetch(\n  input: URL | RequestInfo,\n  init?: RequestInit,\n): Promise<ReadableStream<string>> {\n  return fromBody(await fetch(new Request(input, init)));\n}\n", "import type { Readable } from \"../types.ts\";\n\n/**\n * Creates an observable that will forever emit `chunk()` every `ms` milliseconds.\n *\n * @param ms Milliseconds between each emit.\n * @returns New observable that emits null values.\n */\nexport function fromTimer<T>(\n  ms: number,\n  chunk: () => T = () => null as T,\n): Readable<T> {\n  let id: number;\n\n  return new ReadableStream<T>({\n    start(controller) {\n      id = setInterval(() => {\n        controller.enqueue(chunk());\n      }, ms);\n    },\n    cancel() {\n      clearInterval(id);\n    },\n  });\n}\n\nexport const every = fromTimer;\n", "/**\n * Symbol indicating the end of a stream. Used with `external`.\n */\n// @ts-ignore ?\nexport const EOF: symbol = Symbol();\nexport type NextFunc<T> = (v: T | typeof EOF) => void;\n\n/**\n * Utility function to create new observables from external sources.\n * Returns an object with two values: the new observable, and a `next` function\n * which will emit a value to `observable` when called.\n * Calling `next` with `EOF` will indicate there are no more values to emit.\n *\n * @typeparam T Type of items to be emitted by the observable.\n */\nexport function external<T>(): {\n  observable: ReadableStream<T>;\n  next: NextFunc<T>;\n} {\n  let next: NextFunc<T>;\n  const observable = new ReadableStream<T>(\n    {\n      start(controller) {\n        next = (v: T | typeof EOF) => {\n          if (v === EOF) {\n            return controller.close();\n          }\n          controller.enqueue(v as T);\n        };\n      },\n    },\n    { highWaterMark: 0 },\n  );\n  return { observable, next: next! };\n}\n", "import type { Readable } from \"../types.ts\";\n\n/**\n * Creates an observable from an `EventTarget`.\n * Each event is turned into an item for the observable.\n *\n * @typeparam K Type of the event target `el`.\n * @typeparam T Type of the events to be emitted, such as `MouseEvent`.\n * @param el Event target to create an observable from.\n * @param name Name of the event to listen to, such as `'click'`.\n * @returns New observable that emits values from the event target.\n */\nexport function fromEvent<K extends HTMLElement, T extends Event = Event>(\n  el: K,\n  name: string,\n  options?: boolean | AddEventListenerOptions,\n): Readable<T> {\n  let listener: EventListener;\n  return new ReadableStream<T>(\n    {\n      start(controller) {\n        listener = (e) => controller.enqueue(e as T);\n        el.addEventListener(name, listener, options);\n      },\n      cancel() {\n        el.removeEventListener(name, listener, options);\n      },\n    },\n    { highWaterMark: 0 },\n  );\n}\n", "import type { Readable } from \"../types.ts\";\nimport { EOF, external } from \"./external.ts\";\n\n/**\n * Creates an observable from a synchronous iterable.\n *\n * @typeparam T Type of items to be emitted by the observable.\n * @param it Iterable to create an observable from.\n * @returns New observable that emits values from the iterable.\n */\nexport function fromIterable<T>(\n  it: Iterable<T> | IterableIterator<T>,\n): Readable<T> {\n  const { next, observable } = external<T>();\n  for (const v of it) {\n    next(v);\n  }\n  next(EOF);\n  return observable;\n}\n", "import type { Readable } from \"../types.ts\";\nimport { fromIterable } from \"./from-iterable.ts\";\n\ntype GeneratorFunc<T> = () => IterableIterator<T>;\n\n/**\n * Creates an observable from a generator that takes no arguments.\n *\n * @typeparam T Type of items to be emitted by the observable.\n * @param f Generator function to create an observable from.\n * @returns New observable that emits values from the generator.\n */\nexport function fromGenerator<T>(f: GeneratorFunc<T>): Readable<T> {\n  return fromIterable(f());\n}\n\nfunction* x() {\n  yield \"one\";\n  yield \"two\";\n}\n\nfromGenerator(x);\n", "import type { Readable } from \"../types.ts\";\nimport { EOF, external } from \"./external.ts\";\n\n/**\n * Creates an observable that emits a set of values.\n *\n * @typeparam T Type of the emitted value.\n * @param vs Values to emit.\n * @returns New observable that emits the given values before ending.\n */\nexport function just<T>(...vs: T[]): Readable<T> {\n  const { next, observable } = external<T>();\n  for (const v of vs) {\n    next(v);\n  }\n  next(EOF);\n  return observable;\n}\n", "import type { Readable } from \"../types.ts\";\nimport { EOF, external } from \"./external.ts\";\n\n/**\n * Creates an observable that emits numbers from `start` to `end`.\n *\n * @param start Number to start emitting from, such as `0`.\n * @param end Number to stop emitting at, inclusive.\n * @returns New observable that emits numbers.\n */\nexport function range(start: number, end: number): Readable<number> {\n  const { observable, next } = external<number>();\n  const len = Math.abs(end - start);\n  const dir = Math.sign(end - start);\n  for (let i = 0; i <= len; i++) {\n    next(start + i * dir);\n  }\n  next(EOF);\n  return observable;\n}\n", "export const read = (cb: CallableFunction) => {\n  return async <T>(stream: ReadableStream<T>) => {\n    for await (const chunk of stream) {\n      await cb(chunk);\n    }\n  };\n};\n", "/**\n * Consumes a ReadableStream by applying a function to each chunk.\n * @param fn - The function to apply to each chunk of the ReadableStream.\n * @returns A function that accepts a ReadableStream and consumes it using the provided function.\n */\nexport function consume<T>(\n  fn: (chunk: T) => unknown,\n): (input: ReadableStream<T>) => Promise<void>;\n\n/**\n * Consumes a ReadableStream using a provided function.\n * @param readable - The ReadableStream to consume.\n * @returns A function that accepts a function to apply to each chunk of the ReadableStream and consumes it.\n */\nexport function consume<T>(\n  readable: ReadableStream<T>,\n): (fn: (chunk: T) => unknown) => Promise<void>;\n\n/**\n * Consumes a ReadableStream by applying a function to each chunk.\n * @param readable - The ReadableStream to consume.\n * @param fn - The function to apply to each chunk of the ReadableStream.\n * @returns A Promise that resolves when the ReadableStream has been fully consumed.\n */\nexport async function consume<T>(\n  readable: ReadableStream<T>,\n  fn: (chunk: T) => unknown,\n): Promise<void>;\n\n/**\n * Consumes a ReadableStream or a function by applying a function to each chunk.\n * @param readable - The ReadableStream or function to consume.\n * @param fn - The function to apply to each chunk of the ReadableStream.\n * @returns A function that accepts a ReadableStream and consumes it using the provided function, or a function that accepts a function to apply to each chunk of the ReadableStream and consumes it.\n */\nexport function consume<T>(\n  readable: ReadableStream<T> | ((chunk: T) => unknown),\n  fn?: (chunk: T) => unknown,\n) {\n  if (readable instanceof ReadableStream) {\n    if (!fn) return (fn: (chunk: T) => unknown) => consume(readable, fn);\n\n    return (async () => {\n      for await (const chunk of readable) await fn(chunk);\n    })();\n  }\n\n  if (typeof readable === \"function\") {\n    return (input: ReadableStream<T>) => consume(input, readable);\n  }\n}\n\n/**\n * Example function that demonstrates the usage of the `consume` function.\n */\nfunction _example() {\n  const readable = new ReadableStream<string>();\n  const log = (chunk: string) => console.log(chunk);\n\n  consume(readable, log);\n\n  consume(readable)(log);\n\n  consume(log)(readable);\n}\n", "export * from \"./subscribe.ts\";\nexport * from \"./post.ts\";\nexport * from \"./write.ts\";\n", "/**\n * Sink for observables that discards all values.\n * Useful to leave at the end of a chain.\n *\n * @typeparam T Type of items emitted by the observable.\n * @param f Function to call for each value before it\u2019s discarded.\n */\nexport function subscribe<T>(f: (v: T) => void = () => {}): WritableStream<T> {\n  return new WritableStream<T>(\n    {\n      write(chunk: T) {\n        f(chunk);\n      },\n    },\n    { highWaterMark: 1 },\n  );\n}\n", "export interface RequestStreamInit extends Omit<RequestInit, \"method\"> {\n  body: ReadableStream<Uint8Array>;\n}\n\nexport class RequestStream extends Request {\n  constructor(input: RequestInfo | URL, init?: RequestStreamInit) {\n    const isReadableStream = init?.body instanceof ReadableStream;\n\n    if (!isReadableStream) {\n      throw new TypeError(\"Invalid body: \" + typeof init?.body);\n    }\n\n    super(input, {\n      method: \"POST\",\n      // @ts-ignore .\n      duplex: \"half\",\n      ...init,\n    });\n  }\n}\n\nexport function post<T extends Uint8Array>(\n  input: RequestInfo | URL,\n  init?: RequestStreamInit,\n): WritableStream<T> {\n  const { readable, writable } = new TransformStream<T, T>();\n\n  const request = new RequestStream(input, {\n    ...init,\n    body: readable,\n  });\n\n  fetch(request);\n\n  return writable;\n}\n\nexport function response<T extends Uint8Array>(\n  init?: ResponseInit,\n): { writable: WritableStream<T>; response: Response } {\n  const { readable, writable } = new TransformStream<T, T>();\n\n  const response = new Response(readable, init);\n\n  return { writable, response };\n}\n", "import type { Writable } from \"../types.ts\";\n\nexport function write<T>(writable: Writable<T>) {\n  const writer = writable.getWriter();\n\n  return async function w(chunk: T): Promise<void> {\n    await writer.ready;\n    await writer.write(chunk);\n  };\n}\n", "export * from \"./each.ts\";\nexport * from \"./lower-case.ts\";\nexport * from \"./map.ts\";\nexport * from \"./pipe.ts\";\nexport * from \"./tap.ts\";\nexport * from \"./text.ts\";\nexport * from \"./upper-case.ts\";\nexport * from \"./log.ts\";\nexport * from \"./to.ts\";\nexport * from \"./to-uint8array.ts\";\n// export * from \"./transform/to-string.ts\";\n// export * from \"./transform/to-number.ts\";\nexport * from \"./debounce.ts\";\nexport * from \"./filter.ts\";\nexport * from \"./check.ts\";\nexport * from \"./apply.ts\";\nexport * from \"./sse.ts\";\n", "import type { Transform } from \"../types.ts\";\n\n/**\n * Calls a function for each item emitted by an observable without\n * waiting for the function to return to forward the item.\n * Exceptions thrown by the function will be caught and ignored.\n *\n * @typeparam T Type of items emitted by the observable.\n * @param f Function called with each emitted value.\n * @returns Transform that emits the same items as the original observable.\n */\nexport function each<T>(\n  f: (x: T) => Promise<unknown> | unknown,\n): Transform<T> {\n  return new TransformStream<T, T>(\n    {\n      async transform(chunk, controller) {\n        controller.enqueue(chunk);\n        try {\n          await f(chunk);\n        } catch {\n          // catch\n        }\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "import type { Transform } from \"../types.ts\";\n\nexport function lowerCase(): Transform<string> {\n  return new TransformStream<string, string>({\n    transform(chunk, controller) {\n      return controller.enqueue(chunk.toLowerCase());\n    },\n  });\n}\n", "import type { Transform } from \"../types.ts\";\n\n/**\n * Returns a `Transform` with the results of applying the given function\n * to each emitted item of the original observable.\n *\n * @typeparam S Type of items emitted by the original observable.\n * @typeparam T Type of items returned by `f`.\n * @param f Function called with each emitted item. If it returns a promise,\n * the result is awaited then emitted.\n * @returns Transform that emits items produced by `f`.\n */\nexport function map<S, T>(f: (x: S) => T | Promise<T>): Transform<S, T> {\n  return new TransformStream<S, T>(\n    {\n      async transform(chunk, controller) {\n        controller.enqueue(await f(chunk));\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "// deno-lint-ignore-file\nimport * as colors from \"./colors.ts\";\nimport { type OutgoingStream } from \"./OutgoingStream.ts\";\nimport { type IncomingStream } from \"./IncomingStream.ts\";\nimport { readable, transform, writable } from \"./mod.ts\";\n\nexport { colors };\nexport const idKey = \"transport-id\";\n\nimport demo from \"./app/echo2.ts\";\nimport { defineStreamHandler } from \"./app/defineStreamHandler.ts\";\nimport { Promised } from \"./utils/Promised.ts\";\n\nconst demoFetch = defineStreamHandler(demo.fetch);\n\nfunction fetch(input: URL | RequestInfo, init?: RequestInit) {\n  const request = input instanceof Request ? input : new Request(input, init);\n\n  return demoFetch(request);\n}\n\n// const fetch = defineStreamHandler(demo.fetch);\n\nexport const isDebug = (): boolean =>\n  typeof Deno !== \"undefined\"\n    ? Deno.env.get(\"DEBUG\") === \"true\"\n    : Boolean(Reflect.get(globalThis, \"DEBUG\"));\n\nObject.assign(globalThis, { isDebug });\n\nconsole.log(\n  colors.green(\"(utils) DEBUG\") + \"=\" +\n    colors.white(isDebug() + \"\"),\n);\n\nexport function mkId<K extends string>(key: K = \"abcdefghkl\" as K) {\n  if (key.length !== 10) {\n    throw new TypeError(\n      `Key format error, required 10 unique chars, got: \"${key}\" (len=${key.length})`,\n    );\n  }\n  const alphaMap = [...key];\n\n  return <I extends string = \"0123456789\">(value: I): K[0] =>\n    [...String(value)].map((num) => alphaMap[Number(num)]).join(\"\");\n}\n\nexport const tid = mkId(\"5aksj3hg7e\".toUpperCase());\nexport const uid = () => tid(Math.random().toString().split(\".\").pop()!);\n\nexport async function waitForStatus(\n  request: Request,\n  status: string,\n  options: { retry: number } = { retry: 10 },\n): Promise<string | null> {\n  if (!request.headers.has(idKey)) {\n    throw new TypeError(`Header \"${idKey}\" missing`);\n  }\n\n  // const reqIdValue = request.headers.get(idKey);\n  const promise = new Promised<string>();\n\n  const response = await fetch(request);\n  const body = response.body!;\n\n  const stream = body.pipeThrough(transform.decode());\n\n  const read = readable.read((_status: string) => {\n    const isOk = String(_status).trim() === String(status).trim();\n    console.log(\n      \"(waitForStatus)\",\n      request.method,\n      request.url,\n      status,\n      _status,\n      isOk,\n    );\n\n    if (isOk && !promise.resolved) {\n      promise.resolved = true;\n      promise.resolve(_status);\n    }\n  });\n\n  read(stream);\n\n  return promise;\n}\n\nexport async function duplexFetch(\n  input: URL | RequestInfo,\n  init?: RequestInit,\n): Promise<Response> {\n  const id = uid(); // String(Math.random()).slice(2);\n  const { body, ...rest } = init || {};\n\n  const headers = Object.assign(Object.create(null), init?.headers, {\n    [idKey]: id,\n  });\n\n  // incoming\n  // outgoing\n  const ready = waitForStatus(\n    new Request(input, { method: \"HEAD\", headers }),\n    \"incoming\",\n  );\n\n  fetch(input, {\n    // @ts-ignore .\n    duplex: \"half\",\n    method: \"POST\",\n    ...rest,\n    headers: {\n      ...headers,\n      \"transport-status\": \"incoming\",\n    },\n    body,\n  });\n\n  await ready;\n\n  return fetch(input, {\n    ...rest,\n    headers: {\n      ...headers,\n      \"transport-status\": \"outgoing\",\n    },\n  });\n}\n\nexport async function delay(ms: number): Promise<unknown> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nexport enum ReadyState {\n  CONNECTING = 0,\n  INCOMING = 1,\n  OUTGOING = 2,\n  OPEN = 3,\n  CLOSED = 4,\n  ERRORED = 5,\n}\n\nexport function* mkRangeIterator(\n  start = 0,\n  end = Infinity,\n  step = 1,\n): Generator<number, number, unknown> {\n  let iterationCount = 0;\n  for (let i = start; i < end; i += step) {\n    iterationCount++;\n    yield i;\n  }\n  return iterationCount;\n}\n\nexport async function* mkRangeAsyncIterator(\n  start = 0,\n  end = Infinity,\n  delay = 100,\n): AsyncGenerator<unknown, number, unknown> {\n  let iterationCount = 0;\n  for (let i = start; i < end; i += 1) {\n    iterationCount++;\n    yield await new Promise((resolve) => {\n      setTimeout(() => resolve(i), delay);\n    });\n  }\n  return iterationCount;\n}\n\nexport function log(\n  _this: IncomingStream | OutgoingStream,\n  method: string,\n  ...value: unknown[]\n) {\n  if (!isDebug()) return;\n  const isIn = _this.constructor.name === \"IncomingStream\";\n  const nameColor = isIn ? colors.cyan : colors.magenta;\n  const nameBg = (a: string) => a;\n\n  console.log(\n    colors.gray(\n      `${(nameColor(\n        nameBg(\n          colors.bold(_this.name) + \"[\" + _this.env + \"]\" + \" /\" +\n            colors.italic(_this.url.pathname) +\n            \" \",\n        ),\n      ))} ${colors.brightWhite(colors.bold(method))}(${\n        colors.brightYellow(_this.id) + \", \" +\n        colors.brightGreen(_this.idx + \"\")\n      }) ${colors.blue(\"=>\")}`,\n    ),\n    ...value,\n  );\n}\n\nexport async function getStream(\n  url: URL | string,\n  transform: TransformStream = new TextDecoderStream(),\n): Promise<{\n  url: URL;\n  id: number;\n  request: Request;\n  response: Response;\n  readable: ReadableStream<string>;\n}> {\n  url = new URL(url, location.href);\n\n  const abortController = new AbortController();\n  const headers = new Headers();\n\n  const request = new Request(url, {\n    method: \"GET\",\n    cache: \"no-cache\",\n    // @ts-ignore ?\n    signal: abortController.signal,\n    headers,\n  });\n\n  const response = await fetch(request);\n  const id = Number(response.headers.get(\"duplex-id\") || \"0\");\n  url.hash = `#${id}`;\n\n  if (!response.body) {\n    throw new Error(`Response body`);\n  }\n\n  const readable = response.body.pipeThrough(transform);\n\n  return {\n    url,\n    id,\n    request,\n    response,\n    readable,\n  };\n}\n\nexport function putStream(\n  url: URL | string,\n  transform: TransformStream = new TextEncoderStream(),\n): {\n  id: number;\n  writable: WritableStream<any>;\n  readable: ReadableStream<any>;\n  readable1: ReadableStream<any>;\n  readable2: ReadableStream<any>;\n  headers: Headers;\n  request: Request;\n  response: Promise<Response>;\n  abortController: AbortController;\n} {\n  url = new URL(url, location.href);\n\n  const { writable, readable } = transform;\n  const [readable1, readable2] = readable.tee();\n  const abortController = new AbortController();\n\n  const headers = new Headers();\n  const id = Number(url.hash.slice(1) || \"0\");\n\n  if (id) {\n    headers.set(\"duplex-id\", String(id));\n  }\n\n  const request = new Request(url, {\n    method: \"PUT\",\n    body: readable1,\n    cache: \"no-cache\",\n    // @ts-ignore ?\n    duplex: \"half\",\n    signal: abortController.signal,\n    headers,\n  });\n\n  const response = fetch(request);\n\n  response.then(async (response) => {\n    if (response.ok) {\n      const message = await response.text();\n\n      console.log(\"[closed]\", message);\n      return;\n    }\n\n    const status = response.status;\n    const message = await response.text();\n\n    throw new Error(`Request failed: ${message}`, { cause: status });\n  }).catch((error: Error) => {\n    console.warn(error.name, error.cause, error.message);\n  });\n\n  const o = {\n    id,\n    writable,\n    readable,\n    readable1,\n    readable2,\n    headers,\n    request,\n    response,\n    abortController,\n  };\n\n  return o;\n}\n\nexport function createRead<T>(\n  readable: ReadableStream<T> | { readable: ReadableStream<T> },\n  cb: (chunk: T) => void,\n): Promise<void> {\n  const reader = (readable instanceof ReadableStream)\n    ? readable.getReader()\n    : readable.readable.getReader();\n\n  async function read(cb: (chunk: T) => void) {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          return;\n        }\n        cb(value);\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  }\n\n  return read(cb);\n}\n\nexport function createWrite<T>(\n  writable: WritableStream<T> | { writable: WritableStream<T> },\n): (chunk: T) => Promise<void> {\n  const writer = (writable instanceof WritableStream)\n    ? writable.getWriter()\n    : writable.writable.getWriter();\n\n  Object.assign(write, { writer });\n\n  async function write(chunk: T) {\n    await writer.ready;\n    await writer.write(chunk);\n  }\n\n  return write;\n}\n\nexport const swapObject = <T extends { [key: PropertyKey]: any }>(\n  obj: T,\n): {\n  [K in keyof T as T[K]]: K;\n} => Object.fromEntries(Object.entries(obj).map(([k, v]) => [v, k]));\n\nexport const valueFromKeyObject = <T extends { [key: PropertyKey]: any }>(\n  obj: T,\n): {\n  [K in keyof T]: K;\n} => Object.fromEntries(Object.entries(obj).map(([k, _v]) => [k as any, k]));\n\nexport const _isTransformStream = <T extends object>(input: T): boolean =>\n  typeof input === \"object\" &&\n  Object.hasOwn(input, \"writable\") && Object.hasOwn(input, \"readable\");\n\nexport const isTransformStream = (a: unknown): a is GenericTransformStream =>\n  typeof a === \"object\" && \"readable\" in a!;\n\ntype LengthOfTuple<T extends any[]> = T extends { length: infer L } ? L\n  : never;\ntype DropFirstInTuple<T extends any[]> = ((...args: T) => any) extends\n  (arg: any, ...rest: infer U) => any ? U : T;\nexport type LastInTuple<T extends any[]> =\n  T[LengthOfTuple<DropFirstInTuple<T>>];\n\nexport class PipelineStream<\n  T extends [TransformStream, ...TransformStream[]],\n> {\n  readable: LastInTuple<T>[\"readable\"];\n  writable: T[0][\"writable\"];\n\n  constructor(\n    private transformers: T,\n    writableStrategy?: QueuingStrategy,\n    readableStrategy?: QueuingStrategy,\n  ) {\n    const [first, ...rest] = this.transformers;\n\n    this.writable = first.writable;\n    this.readable = rest.reduce(\n      (readable, transform) => readable.pipeThrough(transform),\n      first.readable,\n    );\n\n    // if (this.transformers.length === 3) {\n    //   this.readable = this.transformers[0].readable\n    //     .pipeThrough(this.transformers[1])\n    //     .pipeThrough(this.transformers[2]);\n    // } else {\n    //   this.readable = this.transformers.at(-1)!.readable;\n    // }\n  }\n}\n\n// const pip = new PipelineStream([\n//   new TransformStream<string, number>(),\n//   new TransformStream<number, symbol>(),\n//   new TransformStream<string, number>(),\n// ]);\n\n// pip.writable.getWriter().write(\"ss\");\n// pip.readable.getReader();\n", "// import { readable, transform, TransportStream } from \"../mod.ts\";\n\nconst alphaMap: [string, ...string[]] = [\n  \"o\",\n  \"i\",\n  \"z\",\n  \"e\",\n  \"q\",\n  \"f\",\n  \"s\",\n  \"x\",\n  \"b\",\n  \"n\",\n];\n\nconst num2alpha = () =>\n  transform.map<number | string, string>((value) =>\n    [...String(value)].map((num) => alphaMap[Number(num)]).join(\"\")\n  );\n\nconst alpha2num = <T extends string>() =>\n  transform.map<T, number>((value) =>\n    Number([...value].map((char) => alphaMap.indexOf(char)).join(\"\"))\n  );\n\nexport default {\n  fetch(request: Request) {\n    return new Response(\n      request.body\n        ?.pipeThrough(transform.decode())\n        .pipeThrough(num2alpha())\n        .pipeThrough(transform.upperCase())\n        .pipeThrough(transform.encode()),\n    );\n  },\n  async start() {\n    const stream = readable.fromTimer(1, Math.random)\n      .pipeThrough(transform.toString())\n      .pipeThrough(transform.encode())\n      .pipeThrough(new TransportStream(\"app/echo2\"))\n      .pipeThrough(transform.decode())\n      .pipeThrough(transform.map((value) => {\n        document.querySelector(\"#output\")!.textContent = value;\n        return value;\n      }));\n\n    for await (const c of stream) {\n      // console.log(c);\n    }\n  },\n};\n", "export class Promised<T> extends Promise<T> {\n  #resolve: (value: T | PromiseLike<T>) => void;\n  #reject: (reason?: unknown) => void;\n\n  resolved: boolean = false;\n  rejected: boolean = false;\n\n  constructor(\n    resolver?: (\n      resolve: (value: T | PromiseLike<T>) => void,\n      reject: (reason?: unknown) => void,\n    ) => void,\n  ) {\n    const that = Object.create(null) as {\n      resolve: (value: T | PromiseLike<T>) => void;\n      reject: (reason?: unknown) => void;\n    };\n\n    super(function (resolve, reject) {\n      Object.assign(that, {\n        resolve,\n        reject,\n      });\n    });\n\n    this.#reject = (reason?: unknown) => {\n      this.rejected = true;\n      that.reject(reason);\n    };\n    this.#resolve = (value: T | PromiseLike<T>) => {\n      this.resolved = true;\n      that.resolve(value);\n    };\n\n    if (resolver) {\n      resolver(this.#resolve, this.#reject);\n    }\n  }\n\n  resolve<V extends T>(value: V) {\n    this.#resolve(value);\n  }\n\n  reject(reason?: unknown) {\n    this.#reject(reason);\n  }\n\n  get state() {\n    return promiseState(this);\n  }\n}\n\nObject.assign(globalThis, { Promised });\n\nexport function promiseState<T>(promise: Promise<T>) {\n  const pendingState = { status: \"pending\" };\n\n  return Promise.race([promise, pendingState]).then(\n    (value) => value === pendingState ? value : { status: \"fulfilled\", value },\n    (reason) => ({ status: \"rejected\", reason }),\n  );\n}\n", "import { transform, writable } from \"../mod.ts\";\nimport type { Promised } from \"../utils/Promised.ts\";\n\nexport class Instance {\n  postRequest?: Request;\n  postResponse?: Promised<Response>;\n  headStream: {\n    body: ReadableStream<Uint8Array>;\n    write: (chunk: string) => Promise<void>;\n  } = createHeadStream();\n}\n\nexport const headers = {\n  \"cache-control\": \"no-cache\",\n  \"access-control-allow-origin\": \"*\",\n  \"access-control-allow-methods\": \"*\",\n  \"access-control-allow-headers\": \"*\",\n  \"access-control-max-age\": \"100\",\n  // sse\n  \"content-type\": \"text/event-stream\",\n};\n\nfunction createHeadStream() {\n  const t = new TransformStream<string, string>();\n  const body = transform.encode(t.readable);\n  const write = writable.write(t.writable);\n  return { body, write: (chunk: string) => write(chunk + \"\\n\") };\n}\n\nexport const instances = new Map<string, Instance>();\n\nexport default {\n  fetch: (async (request) => {\n    console.log(\"handler\", request.method, request.url);\n\n    return new Response(\n      request.body\n        ?.pipeThrough(transform.decode())\n        .pipeThrough(transform.map((val) => `data: ${val}\\n\\n`))\n        .pipeThrough(transform.encode()),\n    );\n  }),\n};\n", "import { idKey } from \"../utils.ts\";\nimport { Promised } from \"../utils/Promised.ts\";\nimport { headers, Instance, instances } from \"./echo1.ts\";\n\ntype ServeHandler = (\n  request: Request,\n  info?: Deno.ServeHandlerInfo,\n) => Response | Promise<Response>;\n\nexport function defineStreamHandler(handler: ServeHandler) {\n  return async function handle(\n    request: Request,\n    info?: Deno.ServeHandlerInfo,\n  ): Promise<Response> {\n    const url = new URL(request.url);\n    const id = request.headers.get(idKey) || url.searchParams.get(idKey);\n\n    if (request.method === \"OPTIONS\") {\n      return new Response(null, { headers: { ...headers, [idKey]: id || \"\" } });\n    }\n\n    if (!id) {\n      throw new TypeError(`Missing \"${idKey}\"`);\n    }\n\n    if (!instances.has(id)) {\n      instances.set(id, new Instance());\n    }\n\n    const instance = instances.get(id)!;\n\n    console.log(\n      \"[\" + request.method + \"] \" + request.url + \" id=\" + id,\n      instances.size,\n    );\n\n    request.signal.addEventListener(\"abort\", () => {\n      if (request.method === \"POST\") {\n        instance.postRequest = undefined;\n      }\n\n      if (request.method === \"GET\") {\n        instances.delete(id);\n        console.log(\n          request.method + \" \" + request.url,\n          String(request.signal.reason),\n        );\n        instance.postResponse?.resolve(new Response(\"Wazzup\", { headers }));\n      }\n    });\n\n    if (request.headers.has(\"transport-status\")) {\n      instance.headStream.write(request.headers.get(\"transport-status\")!);\n    }\n\n    if (request.method === \"HEAD\") {\n      // 200 OK\n      // 201 Created\n      // 202 Accepted\n      return new Response(instance.headStream.body, {\n        status: 200,\n        headers: {\n          ...headers,\n          [idKey]: id,\n        },\n      });\n    }\n\n    if (request.method === \"POST\") {\n      instance.postRequest = request;\n      instance.postResponse = new Promised<Response>();\n      // instance.headStream.write(String(201));\n\n      return instance.postResponse;\n    }\n\n    if (request.method === \"GET\") {\n      const response = await handler(instance.postRequest || request, info);\n      for (const [key, value] of new Headers(headers)) {\n        response.headers.set(key, value);\n      }\n\n      response.headers.set(idKey, id);\n\n      return response;\n    }\n\n    return new Response(\"Bad request!!!\", { status: 400 });\n  };\n}\n", "import type {\n  StrictStream,\n  StrictStreamMapper,\n  StrictStreamPlumber,\n} from \"../types.ts\";\nimport { isTransformStream } from \"../utils.ts\";\n\nexport const transform =\n  <I, O>(transform: TransformStream<I, O>) =>\n  (input: ReadableStream<I>): ReadableStream<O> => {\n    return input.pipeThrough(transform);\n  };\n\nexport function pipe<In, Out>(\n  mapper: StrictStreamMapper<In, Out> | TransformStream<In, Out>,\n): StrictStreamPlumber<In, Out> {\n  const streamMapper: StrictStreamMapper<In, Out> = (input: StrictStream<In>) =>\n    isTransformStream(mapper) ? transform(mapper)(input) : mapper(input);\n\n  // todo: make it work\n  if (isTransformStream(mapper)) {\n    Object.defineProperties(streamMapper, {\n      readable: {\n        get: () => mapper.readable,\n        enumerable: true,\n      },\n      writable: {\n        get: () => mapper.writable,\n        enumerable: true,\n      },\n    });\n  }\n\n  // @ts-ignore ?\n  streamMapper.pipe = <Output>(\n    mapper: StrictStreamMapper<Out, Output> | TransformStream<Out, Output>,\n  ) => {\n    return pipe<In, Output>((input: StrictStream<In>) => {\n      const nextStream = streamMapper(input);\n      return isTransformStream(mapper)\n        ? transform(mapper)(nextStream)\n        : mapper(nextStream);\n    });\n  };\n\n  return streamMapper as StrictStreamPlumber<In, Out>;\n}\n", "import type { Transform } from \"../types.ts\";\nimport { each } from \"./each.ts\";\n\n/**\n * Alias for {@link each}.\n */\nexport function tap<T>(f: (x: T) => void): Transform<T, T> {\n  return each(f);\n}\n", "import type { Transform } from \"../types.ts\";\n\nexport function encode(): TextEncoderStream;\n\nexport function encode(\n  input: ReadableStream<string>,\n): ReadableStream<Uint8Array>;\n\nexport function encode(\n  input?: ReadableStream<string>,\n): ReadableStream<Uint8Array> | Transform<string, Uint8Array> {\n  return input\n    ? input.pipeThrough(new TextEncoderStream())\n    : new TextEncoderStream();\n}\n\nexport function decode(): TextDecoderStream;\n\nexport function decode(\n  input: ReadableStream<Uint8Array>,\n): ReadableStream<string>;\n\nexport function decode(\n  input?: ReadableStream<Uint8Array>,\n): ReadableStream<string> | Transform<Uint8Array, string> {\n  return input\n    ? input.pipeThrough(new TextDecoderStream())\n    : new TextDecoderStream();\n}\n", "import type { Transform } from \"../types.ts\";\n\nexport function upperCase(): Transform<string> {\n  return new TransformStream<string, string>({\n    transform(chunk, controller) {\n      return controller.enqueue(chunk.toUpperCase());\n    },\n  });\n}\n", "import type { Transform } from \"../types.ts\";\n\nexport function log<T>(tag: string = \"\"): Transform<T> {\n  return new TransformStream<T, T>(\n    {\n      start() {\n        console.warn(tag, \"started\");\n      },\n      async transform(chunk, controller) {\n        controller.enqueue(chunk);\n        console.log(tag, await chunk);\n      },\n      async cancel(reason) {\n        await Promise.resolve(console.warn(tag, \"canceled\", reason));\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "import type { IOFunction, Transform } from \"../types.ts\";\nimport { map } from \"./map.ts\";\n\nexport const to = <I, O>(\n  func: IOFunction<I, O>,\n): Transform<I, O> => map(func);\n\nexport const newNumber = <T>(input: T) => new Number(input);\nexport const toNumeric = <I>() => to(Number);\nexport const toNumber = <I>() => to((input: I) => new Number(input));\nexport const toString = <I>() => to<I, string>(String);\nexport const toUpperCase = <I extends string>() =>\n  to<I, string>((val) => val.toUpperCase());\n\nexport const toLine = <I extends string>(separator = \"\\n\") =>\n  to((i: I) => i.concat(separator));\n\nexport const toFixed = <I>(fd?: number) => {\n  const fn = (fd?: number) => <T>(input: T) => (new Number(input)).toFixed(fd);\n  const mapper = fn(fd)<I>;\n\n  return to(mapper);\n};\n\nexport const toPrecision = <I>(precision?: number) => {\n  const fn = (fd?: number) => <T>(input: T) =>\n    (new Number(input)).toPrecision(fd);\n  const mapper = fn(precision)<I>;\n\n  return to(mapper);\n};\n\nconst alphaMap: [string, ...string[]] = [\n  \"o\", // = 0\n  \"i\", // = 1\n  \"2\", // = 2\n  \"e\", // = 3\n  \"q\", // = 4\n  \"f\", // = 5\n  \"s\", // = 6\n  \"x\", // = 7\n  \"6\", // = 8\n  \"n\", // = 9\n  \".\", // = .\n];\n\nexport const toNumAlpha = <T extends number | string>() =>\n  map<T, string>((value) =>\n    [...String(value)].map((num) => alphaMap[Number(num)]).join(\"\")\n  );\n\nexport const toAlphaNum = <T extends string | number>() =>\n  map<T, number>((value) =>\n    Number([...String(value)].map((char) => alphaMap.indexOf(char)).join(\"\"))\n  );\n\nexport function demo() {\n  let id = 0;\n  return new ReadableStream<number>({\n    start(ctrl) {\n      id = setInterval(() => {\n        ctrl.enqueue(Number.MAX_SAFE_INTEGER / Math.random());\n      }, 1);\n\n      console.log(\"started\", id);\n\n      //   setTimeout(() => {\n      //     clearInterval(this.id);\n      //   }, 5000);\n    },\n    cancel() {\n      clearInterval(id);\n      console.log(\"cancel\", id);\n    },\n  })\n    .pipeThrough(toPrecision(20))\n    .pipeThrough(toNumAlpha())\n    .pipeThrough(toUpperCase())\n    .pipeThrough(toLine(\"\\n\"))\n    .pipeThrough(\n      map((val) => {\n        document.body.innerHTML =\n          `<h1 style=\"margin:20px\"><code>${val}</code></h1>`;\n        return val;\n      }),\n    );\n  // .pipeThrough(to(parseFloat));\n  // .pipeThrough(toString());\n  // .pipeThrough(to((c) => [...c]));\n  // .pipeThrough(toNumber())\n  // .pipeThrough(toFixed(2))\n  // .pipeThrough(toLine());\n}\n", "export class Uint8ArrayTransformStream<T> extends TransformStream<\n  T,\n  Uint8Array\n> {\n  constructor() {\n    const encoder = new TextEncoder();\n\n    super({\n      start() {}, // required.\n      async transform(chunk, controller) {\n        chunk = await chunk;\n        switch (typeof chunk) {\n          case \"object\":\n            // just say the stream is done I guess\n            if (chunk === null) {\n              controller.terminate();\n            } else if (ArrayBuffer.isView(chunk)) {\n              controller.enqueue(\n                new Uint8Array(\n                  chunk.buffer,\n                  chunk.byteOffset,\n                  chunk.byteLength,\n                ),\n              );\n            } else if (\n              Array.isArray(chunk) &&\n              chunk.every((value) => typeof value === \"number\")\n            ) {\n              controller.enqueue(new Uint8Array(chunk));\n            } else if (\n              typeof chunk.valueOf === \"function\" &&\n              chunk.valueOf() !== chunk\n            ) {\n              this.transform!(chunk.valueOf() as T, controller); // hack\n            } else if (\"toJSON\" in chunk) {\n              this.transform!(JSON.stringify(chunk) as T, controller);\n            }\n            break;\n          case \"symbol\":\n            controller.error(\"Cannot send a symbol as a chunk part\");\n            break;\n          case \"undefined\":\n            controller.error(\"Cannot send undefined as a chunk part\");\n            break;\n          default:\n            controller.enqueue(encoder.encode(String(chunk)));\n            break;\n        }\n      },\n      flush() {\n        /* do any destructor work here */\n      },\n    });\n  }\n}\n\nexport function toUint8Array<T>(): Uint8ArrayTransformStream<T> {\n  return new Uint8ArrayTransformStream<T>();\n}\n", "import type { Transform } from \"../types.ts\";\n\n/**\n * Returns a `Transform` where items are only emitted if `ms` milliseconds\n * pass without new a new emit by the source observable. If a new value is\n * emitted, the \u201Ccooldown\u201D is restarted and the old value is discarded.\n *\n * @typeparam T Type of items emitted by the observable.\n * @param ms Milliseconds to wait before emitting an item.\n * @returns Transform that emits some items from the original observable.\n */\nexport function debounce<T>(ms: number): Transform<T> {\n  let timeout: number;\n  let timeoutP: Promise<unknown>;\n  let savedChunk: T;\n  return new TransformStream(\n    {\n      transform(chunk, controller) {\n        savedChunk = chunk;\n        if (timeout > 0) {\n          clearTimeout(timeout);\n        }\n        timeoutP = new Promise((resolve) => {\n          // @ts-ignore NodeJS types are interfering here\n          timeout = setTimeout(() => {\n            controller.enqueue(savedChunk);\n            timeout = 0;\n            resolve(undefined);\n          }, ms);\n        });\n      },\n      async flush() {\n        await timeoutP;\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "import type { Transform } from \"../types.ts\";\n\n/**\n * Returns a `Transform` that emits all items for which `f` returns true.\n *\n * @typeparam T Type of items emitted by the observable.\n * @param f Function called with each emitted item. If it returns `true`, the\n * item is emitted. Otherwise the item is discarded.\n * @returns Transform that emits some items from the original observable.\n */\nexport function filter<T>(f: (x: T) => boolean): Transform<T> {\n  return new TransformStream<T, T>(\n    {\n      transform(chunk, controller) {\n        if (f(chunk)) {\n          controller.enqueue(chunk);\n        }\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "import type { Transform } from \"../types.ts\";\n\nexport function check<T>(f: (x: T) => boolean, message?: string): Transform<T> {\n  return new TransformStream<T, T>(\n    {\n      transform(chunk, controller) {\n        if (!f(chunk)) {\n          throw new TypeError(\n            `Check Failed: ${\n              message ||\n              \"type: \" + typeof chunk + \" validate func: \" + String(f)\n            }`,\n          );\n        }\n        controller.enqueue(chunk);\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "import type { Transform } from \"../types.ts\";\n\n/**\n * Applies a transformer function to create a Transform stream.\n *\n * @template S The type of the input data.\n * @template T The type of the transformed data.\n * @param {TransformerTransformCallback<S, T>} transformer The transformer function to apply to each chunk of data.\n * @returns {Transform<S, T>} The Transform stream.\n */\nexport function apply<S, T>(\n  transformer: TransformerTransformCallback<S, T>,\n): Transform<S, T> {\n  return new TransformStream<S, T>(\n    {\n      async transform(chunk, controller) {\n        try {\n          await transformer(chunk, controller);\n        } catch (e) {\n          controller.error(e);\n        }\n      },\n    },\n    { highWaterMark: 1 },\n    { highWaterMark: 0 },\n  );\n}\n", "import { isTransformStream } from \"../utils.ts\";\n\nexport function pipe<T extends (TransformStream | Transformer)[]>(\n  ...transforms: T\n) {\n  return <R>(readable: ReadableStream<R>) => {\n    const ts = transforms.map((o) =>\n      !isTransformStream(o) ? new TransformStream(o) : o\n    );\n\n    const result = ts.reduce((r, t) => r.pipeThrough(t), readable);\n\n    return result as unknown as (typeof ts)[-1][\"readable\"];\n  };\n}\n", "// deno-lint-ignore-file no-explicit-any\nimport { pipe } from \"./pipe.ts\";\n\nexport class PipeStream<\n  I = any,\n  O = any,\n> {\n  //\n  declare writer: WritableStreamDefaultWriter<I>;\n  declare reader: ReadableStreamDefaultReader<O>;\n  //\n  declare readable: ReadableStream<O>;\n  declare writable: WritableStream<I>;\n  declare transformers: (TransformStream<I, O> | Transformer<I, O>)[];\n\n  constructor(\n    ...transformers: (TransformStream | Transformer | undefined)[]\n  ) {\n    const { writable, readable } = new TransformStream();\n    const pipeline = transformers.filter(\n      Boolean,\n    ) as (TransformStream | Transformer)[];\n\n    this.readable = pipe(...pipeline)(readable);\n    this.writable = writable;\n\n    this.transformers = pipeline;\n  }\n\n  async write(message: I) {\n    this.writer = this.writer || this.writable.getWriter();\n\n    await this.writer.ready;\n    await this.writer.write(message);\n  }\n\n  async read(cb: (chunk: O) => void) {\n    for await (const chunk of this.readable) {\n      await cb(chunk);\n    }\n  }\n}\n", "/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n *\n * Based on code from the {@link https://github.com/EventSource/eventsource | EventSource module},\n * which is licensed under the MIT license. And copyrighted the EventSource GitHub organisation.\n */\nimport type { EventParseCallback, SSEParser } from \"./types.ts\";\n\n/**\n * Creates a new EventSource parser.\n *\n * @param onParse - Callback to invoke when a new event is parsed, or a new reconnection interval\n *                  has been sent from the server\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(onParse?: EventParseCallback): SSEParser {\n  // Processing state\n  let isFirstChunk: boolean;\n  let buffer: string;\n  let startingPosition: number;\n  let startingFieldLength: number;\n\n  // Event state\n  let eventId: string | undefined;\n  let eventName: string | undefined;\n  let data: string;\n  let comment: string | undefined;\n  let to: number | \"*\" | undefined;\n  let rest: { [key: string]: unknown } = {};\n\n  // result\n  let result: { [key: PropertyKey]: unknown } | undefined;\n\n  reset();\n  Object.defineProperty(feed, \"buffer\", { get: () => buffer });\n  feed.reset = reset;\n  return { push: feed, reset };\n\n  function reset(): void {\n    isFirstChunk = true;\n    buffer = \"\";\n    startingPosition = 0;\n    startingFieldLength = -1;\n    result = undefined;\n\n    eventId = undefined;\n    eventName = undefined;\n    comment = undefined;\n    // @ts-ignore .\n    data = undefined;\n    to = undefined;\n    rest = {};\n  }\n\n  function feed(chunk: string = \"\") {\n    if (result) {\n      reset();\n    }\n\n    buffer = buffer ? buffer + chunk : chunk;\n\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream.\n    // Note that we do not strip any non - UTF8 BOM, as eventsource streams are\n    // always decoded as UTF8 as per the specification.\n    if (isFirstChunk && hasBom(buffer)) {\n      buffer = buffer.slice(BOM.length);\n    }\n\n    isFirstChunk = false;\n\n    // Set up chunk-specific processing state\n    const length = buffer.length;\n    let position = 0;\n    let discardTrailingNewline = false;\n\n    // Read the current buffer byte by byte\n    while (position < length) {\n      // EventSource allows for carriage return + line feed, which means we\n      // need to ignore a linefeed character if the previous character was a\n      // carriage return\n      // @todo refactor to reduce nesting, consider checking previous byte?\n      // @todo but consider multiple chunks etc\n      if (discardTrailingNewline) {\n        if (buffer[position] === \"\\n\") {\n          ++position;\n        }\n        discardTrailingNewline = false;\n      }\n\n      let lineLength = -1;\n      let fieldLength = startingFieldLength;\n      let character: string;\n\n      for (\n        let index = startingPosition;\n        lineLength < 0 && index < length;\n        ++index\n      ) {\n        character = buffer[index];\n        if (character === \":\" && fieldLength < 0) {\n          fieldLength = index - position;\n        } else if (character === \"\\r\") {\n          discardTrailingNewline = true;\n          lineLength = index - position;\n        } else if (character === \"\\n\") {\n          lineLength = index - position;\n        }\n      }\n\n      if (lineLength < 0) {\n        startingPosition = length - position;\n        startingFieldLength = fieldLength;\n        break;\n      } else {\n        startingPosition = 0;\n        startingFieldLength = -1;\n      }\n\n      parseEventStreamLine(buffer, position, fieldLength, lineLength);\n\n      position += lineLength + 1;\n    }\n\n    if (position === length) {\n      // If we consumed the entire buffer to read the event, reset the buffer\n      buffer = \"\";\n    } else if (position > 0) {\n      // If there are bytes left to process, set the buffer to the unprocessed\n      // portion of the buffer only\n      buffer = buffer.slice(position);\n    }\n\n    return result || feed;\n  }\n\n  function parseEventStreamLine(\n    lineBuffer: string,\n    index: number,\n    fieldLength: number,\n    lineLength: number,\n  ) {\n    if (lineLength === 0) {\n      // We reached the last line of this event\n      // if (data.length > 0) {\n      result = {\n        type: \"event\",\n        id: eventId as unknown as number,\n        to,\n        // @ts-ignore >\n        event: eventName || undefined,\n        comment,\n        data: data ? data.slice(0, -1) : data, // remove trailing newline,\n        ...rest,\n      };\n\n      if (typeof onParse === \"function\") {\n        // @ts-ignore .\n        onParse(result);\n      }\n      to = undefined;\n      // @ts-ignore .\n      data = undefined;\n      comment = undefined;\n      eventId = undefined;\n\n      // }\n\n      eventName = undefined;\n      return;\n    }\n\n    const noValue = fieldLength < 0;\n    const field = lineBuffer.slice(\n      index,\n      index + (noValue ? lineLength : fieldLength),\n    );\n    let step = 0;\n\n    if (noValue) {\n      step = lineLength;\n    } else if (lineBuffer[index + fieldLength + 1] === \" \") {\n      step = fieldLength + 2;\n    } else {\n      step = fieldLength + 1;\n    }\n\n    const position = index + step;\n    const valueLength = lineLength - step;\n    const value = lineBuffer.slice(position, position + valueLength).toString();\n\n    if (field === \"data\") {\n      if (!data) {\n        data = \"\";\n      }\n      data += value ? `${value}\\n` : \"\\n\";\n      // if (value) {\n      //   data = `${data}${value}\\n`\n      // }\n    } else if (field === \"event\") {\n      eventName = value;\n    } else if (field === \"\") {\n      comment = value;\n    } else if (field === \"id\" && !value.includes(\"\\u0000\")) {\n      eventId = value;\n    } else if (field === \"to\") {\n      to = value === \"*\" ? value : Number(value);\n    } else if (field === \"retry\") {\n      const retry = parseInt(value, 10);\n      if (!Number.isNaN(retry)) {\n        // @ts-ignore .\n        if (typeof onParse === \"function\") {\n          // @ts-ignore .\n          onParse({ type: \"reconnect-interval\", value: retry });\n        } else {\n          rest.type = \"reconnect-interval\";\n          rest.retry = retry;\n        }\n      }\n    } else {\n      rest[field] = value;\n    }\n  }\n}\n\nconst BOM = [239, 187, 191];\n\nfunction hasBom(buffer: string) {\n  return BOM.every((charCode: number, index: number) =>\n    buffer.charCodeAt(index) === charCode\n  );\n}\n", "import { EventSourceMessage } from \"./EventSourceMessage.ts\";\nimport { createParser } from \"./parser.ts\";\n\nexport function parse(\n  input: string,\n): EventSourceMessage {\n  const result = createParser().push(input);\n\n  if (typeof result === \"function\") {\n    throw new TypeError(`Parse failed`);\n  }\n\n  return result; // new EventSourceMessage(result);\n}\n", "import type { EventSourceMessage } from \"./EventSourceMessage.ts\";\n\nexport const NEWLINE_REGEXP = /\\r\\n|\\r|\\n/;\n\nexport function assertHasNoNewline(value: string, varName: string) {\n  if (value.match(NEWLINE_REGEXP) !== null) {\n    throw new RangeError(`${varName} cannot contain a newline`);\n  }\n}\n\n/**\n * Converts a server-sent message object into a string for the client.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#event_stream_format}\n */\n\nexport function stringify(message: EventSourceMessage): string {\n  const lines = [];\n  if (message.comment) {\n    assertHasNoNewline(message.comment, \"`message.comment`\");\n    lines.push(`:${message.comment}`);\n  }\n  if (message.event) {\n    assertHasNoNewline(message.event, \"`message.event`\");\n    lines.push(`event:${message.event}`);\n  }\n  if (message.data) {\n    message.data.split(NEWLINE_REGEXP).forEach((line) =>\n      lines.push(`data:${line}`)\n    );\n  }\n  if (message.id) {\n    assertHasNoNewline(message.id.toString(), \"`message.id`\");\n    lines.push(`id:${message.id}`);\n  }\n  if (message.retry) lines.push(`retry:${message.retry}`);\n\n  return lines.join(\"\\n\") + \"\\n\\n\";\n}\n", "/**\n * Represents a message in the Server-Sent Event (SSE) protocol.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#fields}\n */\n\nimport { parse } from \"./parse.ts\";\nimport { stringify } from \"./stringify.ts\";\n\nexport interface EventSourceMessage {\n  /** Ignored by the client. */\n  comment?: string;\n  /** A string identifying the type of event described. */\n  event?: string;\n  /** The data field for the message. Split by new lines. */\n  data?: string;\n  /** The event ID to set the {@linkcode EventSource} object's last event ID value. */\n  id?: string | number;\n  /** The reconnection time. */\n  retry?: number;\n}\n\nexport class EventSourceMessage implements EventSourceMessage {\n  /** Ignored by the client. */\n  declare comment?: string;\n  /** A string identifying the type of event described. */\n  declare event?: string;\n  /** The data field for the message. Split by new lines. */\n  declare data?: string;\n  /** The event ID to set the {@linkcode EventSource} object's last event ID value. */\n  declare id?: string | number;\n  /** The reconnection time. */\n  declare retry?: number;\n  declare private type?: \"reconnect-interval\" | \"event\";\n  declare private readonly raw?: string;\n\n  constructor(\n    input: EventSourceMessage | string,\n    transform?: (message: EventSourceMessage) => EventSourceMessage,\n  ) {\n    if (typeof input === \"string\") {\n      const rawInput = input;\n      input = parse(input);\n      Object.defineProperty(this, \"raw\", {\n        get() {\n          return rawInput;\n        },\n      });\n    }\n\n    Object.defineProperty(this, \"type\", {\n      get: () =>\n        typeof this.retry !== \"undefined\" ? \"reconnect-interval\" : \"event\",\n    });\n\n    for (const key of [\"comment\", \"event\", \"data\", \"id\", \"retry\"] as const) {\n      if (input && typeof input[key] !== \"undefined\") {\n        Object.defineProperty(this, key, {\n          value: input[key],\n          enumerable: true,\n          writable: true,\n          configurable: true,\n        });\n      }\n    }\n    // apply transform\n    if (transform) {\n      Object.assign(this, transform(this));\n    }\n  }\n\n  toString() {\n    return stringify(this);\n  }\n}\n", "import { PipeStream } from \"../PipeStream.ts\";\nimport { EventSourceMessage } from \"./EventSourceMessage.ts\";\nimport { createParser } from \"./parser.ts\";\nimport type { SSEParser } from \"./types.ts\";\n\nconst textDecoder = new TextDecoder();\n\nexport class EventSourceDecoderStream extends PipeStream {\n  constructor() {\n    const instance = Object.create(null) as {\n      controller: TransformStreamDefaultController<EventSourceMessage>;\n      parser: SSEParser;\n    };\n\n    super(\n      {\n        transform(chunk, controller) {\n          controller.enqueue(\n            chunk instanceof Uint8Array ? textDecoder.decode(chunk) : chunk,\n          );\n        },\n      } as Transformer<Uint8Array | string, string>,\n      {\n        start(controller) {\n          Object.assign(instance, {\n            controller,\n            parser: createParser((message) =>\n              instance.controller.enqueue(new EventSourceMessage(message))\n            ),\n          });\n        },\n        transform(chunk) {\n          instance.parser.push(chunk);\n        },\n      } as Transformer<string, EventSourceMessage>,\n    );\n  }\n}\n", "import { stringify } from \"./stringify.ts\";\nimport type { EventSourceMessage } from \"./EventSourceMessage.ts\";\nimport { PipeStream } from \"../PipeStream.ts\";\n\nexport class EventSourceEncoderStream extends PipeStream {\n  constructor() {\n    super(\n      {\n        transform(message, controller) {\n          controller.enqueue(stringify(message));\n        },\n      } as Transformer<EventSourceMessage, string>,\n      new TextEncoderStream(),\n    );\n  }\n}\n", "import { EventSourceDecoderStream } from \"../transport/ess/EventSourceDecoderStream.ts\";\nimport { EventSourceEncoderStream } from \"../transport/ess/EventSourceEncoderStream.ts\";\n\nconst encoder = () => new EventSourceEncoderStream();\nconst decoder = () => new EventSourceDecoderStream();\n\nexport const sse = { encoder, decoder };\n", "// new order\n\nexport * from \"./RequestDuplex.ts\";\nexport * from \"./RequestStream.ts\";\n\nexport * from \"./fetchDuplex.ts\";\nexport * from \"./handle.ts\";\nexport * from \"./Transporter.ts\";\nexport * from \"./PipeStream.ts\";\n\nexport * from \"./TextTransporter.ts\";\nexport * from \"./EventSourceTransporter.ts\";\nexport * from \"./JSONTransporter.ts\";\n\n// old\n\nexport * from \"./TextTransportStream.ts\";\n// export * from \"./PipeStream.ts\";\n\nexport * from \"./TransportStream.ts\";\nexport * from \"./pipeTo.ts\";\nexport * from \"./pipe.ts\";\n\n// export * from \"./XResponse.ts\";\n\nexport * from \"./app/Route.ts\";\nexport * from \"./app/Router.ts\";\nexport * from \"./app/App.ts\";\nexport * from \"./app/Methods.ts\";\n// export * as SSE from \"./app/SSE.ts\";\nexport * as ess from \"./ess/mod.ts\";\n\n// export * from \"./Router.ts\";\n// export * from \"./App.ts\";\n\n// export * from \"./Tapp.ts\";\n// export * from \"./_Transporter.ts\";\n// export * from \"./TextTransporter.ts\";\n// export * from \"./EventSourceTransporter.ts\";\n// export * from \"./JSONTransporter.ts\";\n\nexport type * from \"./types.ts\";\n", "import type { Route } from \"./app/Route.ts\";\nimport type { Context, Request, ServeHandlerReturn } from \"./types.ts\";\n\nexport type URLPatternResultParams = { [key: string]: string | undefined };\n\nexport enum METHOD {\n  GET = \"GET\",\n  HEAD = \"HEAD\",\n  POST = \"POST\",\n  PUT = \"PUT\",\n  DELETE = \"DELETE\",\n  OPTIONS = \"OPTIONS\",\n  PATCH = \"PATCH\",\n  ANY = \"ANY\",\n}\n\nexport const METHOD_ARR = Object.entries(METHOD).map(\n  ([, value]) => value,\n);\n\nexport type METHOD_MAP = {\n  [M in METHOD]: M;\n};\n\nexport type RouteFactoryMethods = Lowercase<keyof typeof METHOD>;\n\nexport type RouteMethod = METHOD;\n// export type RouteHandler = TApp.Handler;\n\nexport type RouteFetch<C = {}> = (\n  request: Request & C,\n  context: Context & C,\n) => ServeHandlerReturn | Promise<ServeHandlerReturn>;\n\nexport type RouterEvents = {\n  onRequest?: RouteFetch;\n  onMatch?: RouteFetch;\n  onResponse?: RouteFetch;\n};\n\nexport type RouteArr = [\n  Route[\"method\"],\n  Route[\"path\"],\n  Route[\"fetch\"],\n];\n\nexport type RoutesInit = Route[] | RouteArr[] | string;\nexport type RouteMeta = {\n  import?: string;\n  module?: Partial<TApp.Serve>;\n};\n", "import type {\n  Context,\n  Request,\n  RequestHandler,\n  ServeHandlerReturn,\n} from \"./types.ts\";\nimport { Promised } from \"../utils/Promised.ts\";\nimport { METHOD } from \"./RoutesInit.ts\";\n\nexport const STREAM_ID_KEY = \"stream-id\";\nexport const STREAM_TYPE_KEY = \"stream-type\";\nexport enum STREAM_TYPE {\n  REQUEST = \"REQUEST\",\n  RESPONSE = \"RESPONSE\",\n}\ntype PromisedResponse = Promised<Response | undefined>;\n// requests map\nconst pmap = new Map<string, PromisedResponse>();\nconst qmap = new Map<string, PromisedResponse>();\n\nObject.assign(duplex, { pmap, qmap });\n\nexport function duplex(\n  handler: RequestHandler,\n  unhandled?: RequestHandler,\n) {\n  async function duplexStream<R extends Request, C extends Context>(\n    request: R,\n    context: C = Object.create(null),\n  ): Promise<ServeHandlerReturn> {\n    const id = request.headers.get(STREAM_ID_KEY);\n    if (!id) {\n      console.log(`(duplex) !id ${request.url}`);\n      return unhandled\n        ? unhandled(request, context)\n        : new Response(null, { status: 400 });\n    }\n\n    const streamType = request.headers.get(\n      STREAM_TYPE_KEY,\n    ) as unknown as STREAM_TYPE;\n\n    const isHalfDuplex = !!id && !!streamType &&\n      ![METHOD.GET, METHOD.HEAD].includes(request.method as METHOD);\n\n    if (!isHalfDuplex) {\n      console.log(\"!isHalfDuplexd\");\n      return handler(request, context);\n    }\n\n    if (id && !pmap.has(id)) {\n      pmap.set(id, new Promised());\n      qmap.set(id, new Promised());\n    }\n\n    if (streamType === STREAM_TYPE.REQUEST) {\n      const getResponse = pmap.get(id)!;\n      const putResponse = qmap.get(id)!;\n\n      getResponse.resolve(await handler(request, context));\n\n      return putResponse;\n    }\n\n    if (streamType === STREAM_TYPE.RESPONSE) {\n      return pmap.get(id);\n    }\n\n    return unhandled\n      ? unhandled(request, context)\n      : new Response(null, { status: 400 });\n\n    // return new Response(null, { status: 400 });\n  }\n\n  return duplexStream;\n}\n", "import { STREAM_ID_KEY, STREAM_TYPE, STREAM_TYPE_KEY } from \"./handle.ts\";\n\nconst isDenoEnv = Reflect.has(globalThis, \"Deno\");\nconst isStreamingBodyRequest = (init?: RequestInit) =>\n  init?.body instanceof ReadableStream &&\n  init.method !== \"GET\" && init.method !== \"HEAD\";\n\nexport type RequestDuplexInit = RequestInit & { duplex?: \"half\" | \"full\" };\n\n/**\n * Represents a duplex request that can send and receive data.\n */\nexport class RequestDuplex extends Request {\n  declare [STREAM_TYPE_KEY]: STREAM_TYPE;\n  declare duplex: \"half\" | \"full\" | undefined;\n\n  /**\n   * Creates a new instance of RequestDuplex.\n   * @param input - The URL or RequestInfo object.\n   * @param init - The optional RequestInit object.\n   */\n  constructor(\n    input: URL | RequestInfo,\n    init?: RequestDuplexInit,\n  ) {\n    input = input || \"\";\n    init = init || {};\n    if (isStreamingBodyRequest(init)) {\n      init.duplex = isDenoEnv ? \"full\" : \"half\";\n    }\n\n    super(input, init);\n\n    if (init.duplex) {\n      this.duplex = init.duplex;\n    }\n\n    if (this.duplex === \"half\") {\n      this.headers.set(STREAM_ID_KEY, Math.random().toString().slice(2));\n      this.headers.set(STREAM_TYPE_KEY, STREAM_TYPE.REQUEST);\n      this[STREAM_TYPE_KEY] = STREAM_TYPE.REQUEST;\n    } else {\n      if (this.headers.has(STREAM_ID_KEY)) {\n        // if (this.headers.get(STREAM_TYPE_KEY) === STREAM_TYPE.REQUEST) {\n        this.headers.set(STREAM_TYPE_KEY, STREAM_TYPE.RESPONSE);\n        this[STREAM_TYPE_KEY] = STREAM_TYPE.RESPONSE;\n        // }\n      }\n    }\n  }\n}\n", "export function useCors(response: Response) {\n  response.headers.set(\"cache-control\", \"no-cache\");\n  response.headers.set(\"access-control-allow-origin\", \"*\");\n  response.headers.set(\"access-control-allow-methods\", \"*\");\n  response.headers.set(\"access-control-allow-headers\", \"*\");\n  response.headers.set(\"access-control-max-age\", \"100\");\n\n  return response;\n}\n", "import { RequestDuplex } from \"./RequestDuplex.ts\";\nimport { STREAM_TYPE, STREAM_TYPE_KEY } from \"./handle.ts\";\nimport { transform } from \"../mod.ts\";\n\nexport type XFetchInput =\n  | string\n  | RequestDuplex\n  | Request\n  | URL;\n\nexport const fetchStream = async <R extends Uint8Array>(\n  input: XFetchInput,\n  rs?:\n    | ReadableStream<R>\n    | Promise<ReadableStream<R>>\n    | Response\n    | Promise<Response>,\n  init?: RequestInit,\n) => {\n  if (rs instanceof Promise) {\n    rs = await rs;\n  }\n\n  const reqBody = rs\n    ? rs instanceof ReadableStream\n      ? rs.pipeThrough(transform.toUint8Array())\n      : rs.body instanceof ReadableStream\n      ? rs.body.pipeThrough(transform.toUint8Array())\n      : readable.of(rs).pipeThrough(transform.toUint8Array())\n    : null;\n\n  return fetchDuplex(input, {\n    ...init,\n    method: reqBody ? \"POST\" : \"GET\",\n    body: reqBody,\n  });\n};\n\nexport function fetchDuplex(\n  input: XFetchInput,\n  init?: RequestInit,\n): Promise<Response> {\n  // @ts-ignore .\n  const fetch = fetchDuplex.fetch as typeof globalThis.fetch ||\n    globalThis.fetch;\n\n  const inputUrl = new URL(\n    typeof input === \"string\"\n      ? input\n      : input instanceof RequestDuplex\n      ? input.url\n      : String(input || globalThis.location),\n    String(globalThis.location),\n  );\n\n  const request = input instanceof RequestDuplex\n    ? input\n    : new RequestDuplex(inputUrl, init);\n\n  if (request.duplex === \"half\") {\n    // console.log(`request.duplex === \"half\"`);\n\n    const request2 = new RequestDuplex(request.url, {\n      method: request.method,\n      headers: {\n        ...Object.fromEntries(request.headers.entries()),\n        [STREAM_TYPE_KEY]: STREAM_TYPE.RESPONSE,\n      },\n    });\n\n    fetch(request);\n\n    return fetch(\n      request2,\n    );\n  } else {\n    console.log(\"(duplex/ call fetch(request))\");\n\n    return fetch(request);\n  }\n}\n\n// @ts-ignore .\nglobalThis.fetch.duplex = fetchDuplex;\n// @ts-ignore .\nglobalThis.fetch.stream = fetchStream;\nfetchDuplex.stream = fetchStream;\n", "export const pipeTo =\n  <T extends Uint8Array>(\n    destination: WritableStream<T> | TransformStream<T, T>,\n  ) =>\n  (source: ReadableStream<T> | Response | Request) =>\n    source instanceof ReadableStream\n      ? source.pipeTo(\n        destination instanceof WritableStream\n          ? destination\n          : destination.writable,\n      )\n      : source.body!.pipeTo(\n        destination instanceof WritableStream\n          ? destination\n          : destination.writable,\n      );\n", "// deno-lint-ignore-file constructor-super no-explicit-any\nimport { useCors } from \"../playground/useCors.ts\";\nimport { Promised } from \"../utils/Promised.ts\";\nimport { fetchStream } from \"./fetchDuplex.ts\";\nimport { PipeStream } from \"./PipeStream.ts\";\nimport { pipeTo } from \"./pipeTo.ts\";\nimport { RequestDuplex } from \"./RequestDuplex.ts\";\n// import { RequestDuplex } from \"./RequestDuplex.ts\";\n\nexport type Transformers<I = any, O = any> =\n  (Transformer<I, O> | TransformStream<I, O>)[];\n\nexport class RequestTransformerStream<W, R> {\n  writable: WritableStream<W>;\n  readable: ReadableStream<R>;\n\n  writer?: WritableStreamDefaultWriter<W>;\n  request: Request;\n\n  constructor(\n    input: URL | RequestInfo,\n    transformers: Transformers | PipeStream<W, R> = [],\n  ) {\n    const ps = transformers instanceof PipeStream\n      ? transformers\n      : new PipeStream<W, R>(...transformers);\n\n    if (input instanceof Request) {\n      input.body?.pipeTo(ps.writable as WritableStream<Uint8Array>);\n      this.request = input;\n      // super(\"/a\");\n    } else {\n      this.request = new RequestDuplex(input, {\n        body: ps.readable,\n        method: \"POST\",\n        //@ts-ignore .\n        duplex: \"half\",\n      });\n    }\n    this.readable = ps.readable;\n    this.writable = ps.writable;\n  }\n\n  pipeTo(destination: WritableStream<R>) {\n    return this.readable.pipeTo(destination);\n  }\n\n  async write(message: W) {\n    this.writer = this.writer || this.writable.getWriter();\n\n    await this.writer.ready;\n    await this.writer.write(message);\n  }\n\n  async read(cb: (chunk: R) => void) {\n    for await (const chunk of this.readable) {\n      await cb(chunk);\n    }\n  }\n}\n\nexport class Transporter<\n  I = any,\n  O = any,\n> extends Response {\n  writable!: WritableStream<I>;\n  readable!: ReadableStream<O>;\n\n  finished!: Promise<void>;\n  closed = new Promised();\n\n  declare private writer?: WritableStreamDefaultWriter<I>;\n\n  static encoder = (): TransformStream | Transformer | undefined => undefined;\n  static decoder = (): TransformStream | Transformer | undefined => undefined;\n\n  constructor(\n    input: URL | RequestInfo,\n    requestTransformers?: Transformers<I, O>,\n    responseInit?: ResponseInit,\n  );\n\n  constructor(\n    input: URL | RequestInfo,\n    requestTransformers?: Transformers<I, O>,\n    responseTransformers?: Transformers<I, O>,\n  );\n\n  constructor(\n    input: URL | RequestInfo,\n    requestTransformers: Transformers<I, O> = [],\n    response?: ResponseInit | Transformers<I, O>,\n  ) {\n    const decoder = new.target.decoder();\n    const encoder = new.target.encoder();\n\n    if (input instanceof Request) {\n      const responseInit = response as ResponseInit;\n\n      const ps = new PipeStream(\n        decoder,\n        ...requestTransformers,\n        encoder,\n      );\n\n      const readable = input.body ? input.body.pipeThrough(ps) : ps.readable;\n      const writable = ps.writable;\n\n      super(readable, responseInit);\n      this.writable = writable;\n      this.readable = readable;\n\n      useCors(this);\n    } else {\n      // fetch request\n      const responseTransformers = (response || []) as Transformers;\n\n      const reqTransform = new PipeStream(...requestTransformers, encoder);\n      const resTransform = new PipeStream(decoder, ...responseTransformers);\n\n      super(resTransform.readable /** init */);\n\n      this.writable = reqTransform.writable;\n      this.readable = resTransform.readable;\n      this.finished = fetchStream(input, reqTransform.readable)\n        .then(pipeTo(resTransform));\n    }\n  }\n\n  async write(message: I) {\n    this.writer = this.writer || this.writable.getWriter();\n\n    await this.writer.ready;\n    await this.writer.write(message);\n  }\n\n  async read(cb: (chunk: O) => void) {\n    for await (const chunk of this.readable) {\n      await cb(chunk);\n    }\n  }\n\n  async close() {\n    if (this.closed.rejected || this.closed.resolved) {\n      throw new TypeError(\n        `Already closed: ${\n          this.closed.rejected\n            ? \"rejected\"\n            : this.closed.resolved\n            ? \"resolved\"\n            : \"unknown\"\n        }`,\n      );\n    }\n\n    if (this.writer) {\n      await this.writer.ready;\n      await this.writer.close();\n      this.writer.releaseLock();\n      delete this.writer;\n    } else {\n      this.writable.close();\n    }\n\n    this.closed.resolve(true);\n  }\n}\n\n// @ts-ignore .\nTransporter.demo = (u = \"/upper\") => {\n  const ts = new PipeStream<string, string>(\n    new TextEncoderStream(),\n    new Transporter(u),\n    new TextDecoderStream(),\n  );\n\n  ts.read(console.log);\n\n  ts.write(\"Hello World\");\n\n  return ts;\n};\n", "import { PipeStream } from \"./PipeStream.ts\";\nimport { Transporter } from \"./Transporter.ts\";\n\nconst EOL = \"\\n\";\n\nexport class JSONEncoderStream extends TransformStream<object, string> {\n  constructor() {\n    super({\n      transform(chunk, controller) {\n        try {\n          controller.enqueue(JSON.stringify(chunk) + EOL);\n        } catch { /** err */ }\n      },\n    });\n  }\n}\nexport class JSONDecoderStream<\n  I extends string = string,\n  O extends object = object,\n> extends TransformStream<I, O> {\n  constructor() {\n    super({\n      transform(chunk, controller) {\n        let runningText = \"\";\n        const objects = chunk.split(EOL);\n        for (const obj of objects) {\n          try {\n            runningText += obj;\n            const result = JSON.parse(runningText);\n            controller.enqueue(result);\n            runningText = \"\";\n          } catch (_e) {\n            // Not a valid JSON object\n          }\n        }\n      },\n    });\n  }\n}\n\nexport class JSONTransporter extends Transporter<object, object> {\n  static encoder<T extends object>() {\n    return new PipeStream<T, Uint8Array>(\n      new JSONEncoderStream(),\n      new TextEncoderStream(),\n    );\n  }\n  static decoder<T extends object>() {\n    return new PipeStream<Uint8Array, T>(\n      new TextDecoderStream(),\n      new JSONDecoderStream(),\n    );\n  }\n}\n\n// @ts-ignore .\nJSONTransporter.demo = (u = \"/json\") => {\n  const ts = new JSONTransporter(u);\n  ts.read(console.log);\n\n  ts.write({ uid: \"serebano\", msg: \"Anybody here?\" });\n\n  return ts;\n};\n", "import { STREAM_TYPE, STREAM_TYPE_KEY } from \"./handle.ts\";\nimport { JSONTransporter } from \"./JSONTransporter.ts\";\nimport { PipeStream } from \"./PipeStream.ts\";\nimport { pipeTo } from \"./pipeTo.ts\";\nimport { RequestDuplex, type RequestDuplexInit } from \"./RequestDuplex.ts\";\n\n/**\n * Represents a request stream that extends the RequestDuplex class.\n */\nexport class RequestStream {\n    static fetch = (\n        ...args: [\n            input: string | URL | Request,\n            init?: RequestInit,\n        ]\n    ) => globalThis.fetch(...args);\n\n    outgoing: RequestDuplex;\n    incoming: RequestDuplex | undefined;\n    response: Response | undefined;\n\n    /**\n     * Fetches the request stream.\n     * @param init - Optional request initialization options.\n     * @returns A Promise that resolves to the response of the request.\n     */\n    async fetch(init?: RequestInit): Promise<Response> {\n        if (this.incoming) {\n            // Duplex\n            // >> send stream.\n            RequestStream.fetch(this.outgoing, init);\n            // << receive stream.\n            this.response = await RequestStream.fetch(this.incoming, init);\n        } else {\n            // << receive stream.\n            this.response = await RequestStream.fetch(this.outgoing, init);\n        }\n\n        return this.response;\n    }\n\n    /**\n     * Creates a new instance of RequestStream.\n     * @param input - The URL or Request object.\n     * @param init - Optional request initialization options.\n     */\n    constructor(input: URL | RequestInfo, init?: RequestDuplexInit) {\n        this.outgoing = new RequestDuplex(input, init);\n        this.incoming = this.outgoing.duplex === \"half\"\n            ? new RequestDuplex(this.outgoing.url, {\n                method: this.outgoing.method,\n                headers: {\n                    ...Object.fromEntries(this.outgoing.headers.entries()),\n                    [STREAM_TYPE_KEY]: STREAM_TYPE.RESPONSE,\n                },\n            })\n            : undefined;\n    }\n\n    static demo = requestStreamDemo;\n}\n\nexport async function requestStreamDemo() {\n    const enc = JSONTransporter.encoder();\n    const dec = JSONTransporter.decoder();\n    const req = new RequestStream(\"/pipe1\", {\n        body: enc.readable,\n        method: \"put\",\n    });\n\n    await req.fetch();\n    req.response?.body?.pipeTo(dec.writable);\n\n    const api = {\n        // request/response\n        outgoing: req.outgoing,\n        incoming: req.incoming,\n        response: req.response,\n        // streams\n        writable: enc.writable,\n        readable: dec.readable,\n        // methods\n        write: enc.write.bind(enc),\n        read: dec.read.bind(dec),\n    };\n\n    // api.read(console.log)\n    // api.write({ uid: 'xxx', msg: 'Iaka asa' })\n\n    // or\n\n    readable.consume(\n        readable.of(\"foo\", \"bar\", \"baz\")\n            .pipeThrough(\n                new PipeStream(\n                    transform.map((msg) => ({ uid: \"xxx\", msg })),\n                    api,\n                ),\n            ),\n        console.log,\n    );\n\n    return api;\n}\n", "import { RequestTransformerStream, Transporter } from \"./Transporter.ts\";\n\nexport class TextTransporter extends Transporter<string, string> {\n  static encoder = (): TransformStream<string, Uint8Array> =>\n    new TextEncoderStream();\n  static decoder = (): TransformStream<Uint8Array, string> =>\n    new TextDecoderStream();\n}\n\n// @ts-ignore .\nTextTransporter.demo = (u = \"/upper\") => {\n  const ts = new TextTransporter(u);\n\n  ts.read(console.log);\n  ts.write(\"Hello World\");\n\n  return ts;\n};\n", "export * from \"./ESS.ts\";\n\nexport * from \"./EventSourceStream.ts\";\nexport * from \"./EventSourceMessage.ts\";\nexport * from \"./EventSourceDecoderStream.ts\";\nexport * from \"./EventSourceEncoderStream.ts\";\n", "import { fetchStream } from \"../fetchDuplex.ts\";\nimport {\n  EventSourceDecoderStream,\n  EventSourceEncoderStream,\n  type EventSourceMessage,\n} from \"./mod.ts\";\nimport { pipeTo } from \"../pipeTo.ts\";\nimport { Promised } from \"../../utils/Promised.ts\";\n\nexport class EventSourceStream {\n  writable: WritableStream<EventSourceMessage>;\n  readable: ReadableStream<EventSourceMessage>;\n\n  finished: Promise<void>;\n  closed: Promised<boolean>;\n\n  declare private writer: WritableStreamDefaultWriter<EventSourceMessage>;\n  declare response: (init: ResponseInit) => Response;\n  body: ReadableStream<Uint8Array>;\n\n  constructor(input: URL | RequestInfo, init?: RequestInit) {\n    const sseEncoder = new EventSourceEncoderStream();\n    const sseDecoder = new EventSourceDecoderStream();\n\n    this.writable = sseEncoder.writable;\n    this.readable = sseDecoder.readable;\n\n    this.body = sseEncoder.readable;\n\n    this.closed = new Promised();\n\n    if (input instanceof Request) {\n      console.log(\"ess input from request\");\n      this.finished = input.body!.pipeTo(sseDecoder.writable);\n      this.response = (init?: ResponseInit) => new Response(this.body, init);\n    } else {\n      this.finished = fetchStream(input, this.body, init)\n        .then(pipeTo(sseDecoder.writable));\n    }\n  }\n\n  async write(message: EventSourceMessage) {\n    this.writer = this.writer || this.writable.getWriter();\n\n    await this.writer.ready;\n    await this.writer.write(message);\n  }\n\n  async read(cb: (chunk: EventSourceMessage) => void) {\n    for await (const chunk of this.readable) {\n      await cb(chunk);\n    }\n  }\n\n  async close() {\n    if (this.closed.rejected || this.closed.resolved) {\n      throw new TypeError(\n        `Already closed: ${\n          this.closed.rejected\n            ? \"rejected\"\n            : this.closed.resolved\n            ? \"resolved\"\n            : \"unknown\"\n        }`,\n      );\n    }\n\n    this.writer = this.writer || this.writable.getWriter();\n\n    await this.writer.ready;\n    await this.writer.close();\n\n    this.closed.resolve(true);\n  }\n}\n\n// @ts-ignore .\nEventSourceStream.demo = () => {\n  const ess = new EventSourceStream(\"/ess-2\");\n\n  ess.read(console.log);\n  ess.write({\n    data: \"Demo\",\n  });\n\n  return ess;\n};\n", "import { EventSourceDecoderStream } from \"./EventSourceDecoderStream.ts\";\nimport { EventSourceEncoderStream } from \"./EventSourceEncoderStream.ts\";\nimport { EventSourceStream } from \"./EventSourceStream.ts\";\nimport { EventSourceMessage } from \"./EventSourceMessage.ts\";\nimport { parse } from \"./parse.ts\";\nimport { stringify } from \"./stringify.ts\";\n\nexport class ESS {\n  static Message = EventSourceMessage;\n  static EncoderStream = EventSourceEncoderStream;\n  static DecoderStream = EventSourceDecoderStream;\n  static Stream = EventSourceStream;\n  static stringify = stringify;\n  static parse = parse;\n}\n", "import { Transporter } from \"./Transporter.ts\";\nimport {\n  EventSourceDecoderStream,\n  EventSourceEncoderStream,\n  type EventSourceMessage,\n} from \"./ess/mod.ts\";\n\nexport class EventSourceTransporter\n  extends Transporter<EventSourceMessage, EventSourceMessage> {\n  static encoder = () => new EventSourceEncoderStream();\n  static decoder = () => new EventSourceDecoderStream();\n}\n\n// @ts-ignore .\nEventSourceTransporter.demo = (u = \"/est-1\") => {\n  const ts = new EventSourceTransporter(u);\n\n  ts.read(console.log);\n\n  ts.write({ data: \"hi es\" });\n\n  return ts;\n};\n", "import { Uint8ArrayTransformStream } from \"../transform/mod.ts\";\nimport { pipe } from \"./pipe.ts\";\n\nexport class TextTransportStream extends Response {\n  finished: Promise<void>;\n\n  constructor(\n    public request: Request,\n    public transformer?: Transformer<string, string>,\n    public init?: ResponseInit,\n  ) {\n    if (!request.body) {\n      throw new TypeError(`Request.body missing`);\n    }\n\n    // 1 request stream transform\n    const {\n      writable,\n      readable,\n    } = new TransformStream<string, string>(transformer);\n\n    super(readable.pipeThrough(new TextEncoderStream()), init);\n\n    this.finished = request.body\n      .pipeThrough(new TextDecoderStream())\n      .pipeTo(writable);\n  }\n}\n", "import { RequestDuplex } from \"./RequestDuplex.ts\";\nimport { PipeStream } from \"./PipeStream.ts\";\n\nexport class TransportStream extends Response {\n  // readable: ReadableStream<Uint8Array>;\n  // finished: Promise<void>;\n  constructor(\n    public request: Request,\n    public transformers: (Transformer | TransformStream)[] = [],\n    public init?: ResponseInit,\n  ) {\n    if (!request.body) {\n      throw new TypeError(`Request.body missing`);\n    }\n\n    const readable = request.body\n      .pipeThrough(new PipeStream(...transformers));\n\n    super(readable, init);\n  }\n\n  static demo = demo;\n}\n\nfunction demo(request: Request) {\n  return new TransportStream(request, [\n    new TextDecoderStream(),\n    {\n      transform(chunk, ctrl) {\n        ctrl.enqueue(chunk.toUpperCase());\n      },\n    } as Transformer<string, string>,\n    new TextEncoderStream(),\n  ], {\n    status: 200,\n  });\n}\n\n// const x = new EventSourceStream(\"https://localhost:8000/sse1\");\n// x.read(console.log);\n// x.write({\n//   data: \"Hello World\",\n// });\n\n// export class EventSourceStream<\n//   I extends SSEMessage = SSEMessage,\n//   O extends Uint8Array = Uint8Array,\n// > extends BaseTransformStream<I, O> {\n//   finished: Promise<void>;\n//   constructor(input: URL | RequestInfo, init?: RequestInit) {\n//     super({\n//       transform(chunk, controller) {\n//         controller.enqueue(chunk);\n//       },\n//     });\n\n//     this.finished = fetchStream(input, this.readable)\n//       .then((res) => res.body.pipeTo(this.writable));\n//   }\n// }\n\nexport function rwStream(stream: ReadableWritablePair) {\n  readable.read(console.log)(stream.readable);\n  return writable.write(stream.writable);\n}\n\nexport const counterReadableStream = (ms = 1000, idx = 0) => {\n  return readable\n    .fromTimer(ms, () => idx >= 10 ? null : \"Count: \" + (++idx));\n};\n\nexport function toRequest<R extends ReadableStream<string>>(readable: R) {\n  return function (input: RequestInfo, init?: RequestInit) {\n    return new RequestDuplex(\n      input,\n      {\n        ...init,\n        method: \"POST\",\n        body: readable.pipeThrough(transform.toUint8Array()),\n      },\n    );\n  };\n}\n\nexport function fromResponse(response: Response) {\n  if (response.body) {\n    return response.body\n      .pipeThrough(transform.decode())\n      .pipeTo(writable.subscribe(console.log));\n  } else {\n    throw new TypeError(`Bad Response.body: ${typeof response.body}`);\n  }\n}\n\n// export function fromFetch(\n//   input: string | URL | Request,\n//   init?: RequestInit | undefined,\n// ): Promise<ReadableStream<Uint8Array>> {\n//   return duplexFetch(input, init).then(fromBody);\n// }\n", "export const mergePath = (...paths: string[]): string => {\n  let p: string = \"\";\n  let endsWithSlash = false;\n\n  for (let path of paths) {\n    /* ['/hey/','/say'] => ['/hey', '/say'] */\n    if (p[p.length - 1] === \"/\") {\n      p = p.slice(0, -1);\n      endsWithSlash = true;\n    }\n\n    /* ['/hey','say'] => ['/hey', '/say'] */\n    if (path[0] !== \"/\") {\n      path = `/${path}`;\n    }\n\n    /* ['/hey/', '/'] => `/hey/` */\n    if (path === \"/\" && endsWithSlash) {\n      p = `${p}/`;\n    } else if (path !== \"/\") {\n      p = `${p}${path}`;\n    }\n\n    /* ['/', '/'] => `/` */\n    if (path === \"/\" && p === \"\") {\n      p = \"/\";\n    }\n  }\n\n  return p;\n};\n", "import { colors } from \"../../utils.ts\";\nimport { mergePath } from \"../../utils/app.ts\";\nimport { METHOD } from \"../RoutesInit.ts\";\nimport type { RouteFetch, RouteMethod } from \"../RoutesInit.ts\";\nimport { duplex } from \"../handle.ts\";\nimport type { Context, Request, RequestHandler } from \"../types.ts\";\n\nexport interface RouteModule {\n  path?: string;\n  method?: string | METHOD;\n  fetch: RouteFetch;\n\n  onError?: Deno.ServeTlsOptions[\"onError\"];\n  onListen?: Deno.ServeTlsOptions[\"onListen\"];\n\n  //\n  onRequest?: RouteFetch;\n  onResponse?: RouteFetch;\n\n  tls?: {\n    key?: string;\n    cert?: string;\n  };\n\n  port?: number;\n  hostname?: string;\n}\n\nexport class Route<\n  M extends RouteMethod = RouteMethod,\n  P extends string = string,\n  F extends RouteFetch = RouteFetch,\n> {\n  static ANY: METHOD.ANY = METHOD.ANY;\n  static GET: METHOD.GET = METHOD.GET;\n  static POST: METHOD.POST = METHOD.POST;\n  static PUT: METHOD.PUT = METHOD.PUT;\n  static PATCH: METHOD.PATCH = METHOD.PATCH;\n  static DELETE: METHOD.DELETE = METHOD.DELETE;\n  static OPTIONS: METHOD.OPTIONS = METHOD.OPTIONS;\n  static HEAD: METHOD.HEAD = METHOD.HEAD;\n\n  method: METHOD;\n  path: string | P;\n  fetch: F;\n\n  static from(module: RouteModule) {\n    const { path, method, fetch, ...options } = module;\n    return new this(\n      (method || Route.ANY) as METHOD,\n      path || \"*\",\n      fetch,\n      options,\n    );\n  }\n\n  declare options: Omit<RouteModule, \"method\" | \"path\" | \"fetch\">;\n\n  constructor(\n    method: M,\n    path: P,\n    fetch: F,\n    options?: Omit<RouteModule, \"method\" | \"path\" | \"fetch\">,\n  ) {\n    this.method = method || METHOD.ANY;\n    this.path = path || \"*\";\n    this.fetch = duplex(fetch as RequestHandler, fetch as RequestHandler) as F;\n\n    if (options) {\n      this.options = options;\n    }\n  }\n\n  private get [Symbol.toStringTag]() {\n    return `[${this.method}] ${this.path}`;\n  }\n\n  private toString() {\n    return `[${this.method}] ${this.path}`;\n  }\n\n  private [Symbol.iterator]() {\n    return [this.method, this.path, this.fetch].values();\n  }\n\n  route<B extends string>(path: B) {\n    const instance = Reflect.construct(\n      this.constructor,\n      [],\n      this.constructor,\n    ) as typeof this;\n\n    const result = Object.assign(instance, { ...this }, {\n      path: mergePath(path, this.path) as `${B}/${P}`,\n    });\n\n    console.log(\"instance\", path, result);\n\n    return result;\n  }\n\n  match(\n    method: METHOD,\n    input: string,\n    base?: string,\n  ): Record<string, unknown> | undefined {\n    const baseURL = /^https?:\\/\\//.test(input) ? undefined : `http://localhost`;\n\n    const res = new URLPattern({\n      pathname: mergePath(base || \"\", this.path),\n    }).exec(input, baseURL)?.pathname.groups;\n\n    if (res) {\n      console.log(\n        `${colors.brightWhite(this.method.toLowerCase())}(${\n          colors.yellow(base || \"\")\n        }${colors.green(this.path)})  [${colors.cyan(method)}] ${\n          colors.brightBlue(new URL(input).pathname)\n        }`,\n      );\n    }\n    // console.log([...this]);\n\n    return res;\n  }\n\n  request(\n    input: URL | RequestInfo,\n    init?: RequestInit | undefined,\n  ) {\n    if (input instanceof Request) {\n      if (init !== undefined) {\n        input = new Request(input, init) as Request;\n      }\n\n      const context = {\n        url: new URL(input.url),\n        method: input.method as METHOD,\n        responseInit: {},\n      } as Context;\n\n      Object.assign(input, { context });\n\n      return this.fetch(input as Request, context);\n    }\n\n    input = input.toString();\n    const path = /^https?:\\/\\//.test(input)\n      ? input\n      : `http://localhost${mergePath(\"/\", input)}`;\n\n    init = init || {};\n    init.method = init.method || this.method;\n    const match = init.method === this.method && this.match(init.method, path);\n\n    if (match) {\n      const request = new Request(path, init) as Request;\n\n      const context = {\n        url: new URL(request.url),\n        method: request.method as METHOD,\n        params: match,\n        responseInit: {},\n      } as Context;\n\n      Object.assign(request, { context });\n\n      const response = this.fetch(request, context);\n      if (response instanceof ReadableStream) {\n        return new Response(response.pipeThrough(transform.toUint8Array()));\n      }\n\n      if (response instanceof Response) {\n        return response;\n      }\n\n      if (response) {\n        return new Response(response as any);\n      }\n    }\n  }\n}\n\n// static create<\n// M extends RouteMethod,\n// P extends string,\n// H extends RouteFetch | Route,\n// >(\n// method: M,\n// path: RoutePath<P>,\n// handle: H,\n// meta?: RouteMeta,\n// ): H extends Route ? Route<H[\"method\"], MergePath<P, H[\"path\"]>, H[\"fetch\"]>\n// : H extends RouteFetch ? Route<M, P, H>\n// : unknown {\n// if (handle instanceof Route) {\n//   // @ts-ignore .\n//   return handle.route(path);\n// }\n// // @ts-ignore .\n// return new Route(method, path, handle, meta);\n// }\n\n// static any<P extends string = `/`, H extends RouteFetch = RouteFetch>(\n//   path: P,\n//   handler: H,\n// ): Route<METHOD.ANY, P, H> {\n//   return new Route(Route.ANY, path, handler);\n// }\n\n// static get<P extends string = `/`, H extends RouteFetch = RouteFetch>(\n//   path: P,\n//   handler: H,\n// ): Route<METHOD.GET, P, H> {\n//   return new Route(Route.GET, path, handler);\n// }\n\n// static factory<B extends string>(\n//   basePath: `${B}` = `/` as `${B}`,\n//   // extend?: X,\n// ) {\n//   const routes: Array<Route> = [];\n\n//   function base<X extends string>(basePath: `${X}`) {\n//     const newPath = mergePath(basePath, api.basePath) as `${MergePath<X, B>}`; //as MergePath<B, X>;\n//     const newApi = Route.factory(newPath);\n\n//     routes.forEach(({ method, path, fetch }) => {\n//       newApi.use(new Route(method, mergePath(newPath, path), fetch));\n//     });\n\n//     return newApi;\n//   }\n\n//   function request<X = B>(\n//     input: URL | RequestInfo,\n//     init?: RequestInit | undefined,\n//   ) {\n//     if (input instanceof Request) {\n//       if (init !== undefined) {\n//         input = new Request(input, init) as Request;\n//       }\n\n//       const context = {\n//         url: new URL(input.url),\n//         method: input.method as Context[\"method\"],\n//         responseInit: {},\n//       } as TApp.Context;\n\n//       Object.assign(input, { context });\n\n//       return api.fetch(input as Request, context);\n//     }\n\n//     input = input.toString();\n//     const path = /^https?:\\/\\//.test(input)\n//       ? input\n//       : `http://localhost${mergePath(\"/\", input)}`;\n//     const request = new Request(path, init) as TApp.Request;\n\n//     const context = {\n//       url: new URL(request.url),\n//       method: request.method as Context[\"method\"],\n//       responseInit: {},\n//     } as TApp.Context;\n\n//     Object.assign(request, { context });\n\n//     return api.fetch(request, context);\n//   }\n\n//   // Object.assign(fetch, { basePath, api });\n//   async function fetch<X = B>(request: Request, context: Context) {\n//     request.context = request.context || context ||\n//       Object.create({\n//         constructor: function Context() {\n//           console.log(\"Context croe\", this);\n//         },\n//       });\n//     context = request.context;\n\n//     for (const route of api.routes) {\n//       if (route.method === METHOD.ANY || request.method === route.method) {\n//         const match = route.match(request.url);\n\n//         if (match) {\n//           context.params = request.params = match;\n//           context.route = route;\n\n//           const response = context.responseRaw = await route.fetch(\n//             request,\n//             context,\n//           );\n\n//           if (typeof response !== \"undefined\") {\n//             return response;\n//           }\n//         }\n//       }\n//     }\n//   }\n\n//   function use<P extends string, H extends RouteFetch | Route>(\n//     path: P | H,\n//     handle?: H,\n//   ) {\n//     if (typeof path === \"string\" && handle) {\n//       const route = (handle instanceof Route)\n//         ? handle.route(mergePath(basePath, path))\n//         : new Route(\n//           Route.ANY,\n//           basePath ? mergePath(basePath, path) as MergePath<B, P> : path,\n//           handle,\n//         );\n\n//       routes.push(route);\n//     } else if (!handle && typeof path !== \"string\") {\n//       handle = path;\n//       if (handle instanceof Route) {\n//         routes.push(handle.route(mergePath(basePath, \"*\")));\n//       } else {\n//         routes.push(new Route(METHOD.ANY, mergePath(basePath, \"*\"), handle));\n//       }\n//     }\n\n//     return api;\n//   }\n\n//   type RouteApi<B extends string> =\n//     & { basePath: `${B}` }\n//     & {\n//       [M in METHOD as Lowercase<M>]: <\n//         X extends B = B,\n//         P extends string = ``,\n//         F extends RouteFetch = RouteFetch,\n//       >(\n//         path: P,\n//         fetch: F,\n//       ) => RouteApi<X>; // Route<METHOD_MAP[M], MergePath<B, P>, H>;\n//     }\n//     & {\n//       get routes(): Array<Route>;\n//       basePath: typeof basePath;\n//       fetch: typeof fetch;\n//       request: typeof request;\n//       base: typeof base;\n\n//       use<X extends B = B, F extends Route = Route>(\n//         route: F,\n//       ): RouteApi<X>; // Route<METHOD.ANY, MergePath<B, H[\"path\"]>, H[\"handler\"]>;\n\n//       use<X extends B = B, H extends RouteFetch = RouteFetch>(\n//         handle: H,\n//       ): RouteApi<X>; // Route<METHOD.ANY, MergePath<B, \"/*\">, H>;\n//       use<\n//         X extends B = B,\n//         P extends string = string,\n//         H extends RouteFetch | Route = RouteFetch,\n//       >(\n//         path: P,\n//         handle: H,\n//       ): RouteApi<X>;\n//     };\n\n//   const api: RouteApi<B> = Object.create(Object.assign({\n//     routes,\n//     use,\n//     fetch,\n//     request,\n//     base,\n//     basePath,\n//   }));\n\n//   const methods = Object.keys(METHOD) as [(keyof typeof METHOD)];\n\n//   for (const key of methods) {\n//     Object.assign(api, {\n//       [key.toLowerCase()]: function <\n//         P extends string,\n//         H extends RouteFetch,\n//       >(\n//         path: P,\n//         handler: H,\n//       ) {\n//         if (typeof path === \"undefined\") {\n//           throw new TypeError(\n//             `Method \"${key.toLowerCase()}\" require at least one argument`,\n//           );\n//         }\n//         const route = new Route(\n//           METHOD[key],\n//           basePath ? mergePath(basePath, path) as MergePath<B, P> : path,\n//           handler,\n//         );\n\n//         routes.push(route);\n\n//         return api;\n//       },\n//     });\n//   }\n\n//   return api;\n// }\n\n// static use<P extends string, H extends RouteFetch | Route>(\n//   path: P,\n//   handle: H,\n// ): H extends RouteFetch ? Route<METHOD.ANY, P, H>\n//   : H extends Route ? Route<H[\"method\"], MergePath<P, H[\"path\"]>, H[\"fetch\"]>\n//   : never {\n//   const route = (handle instanceof Route)\n//     ? handle.route(path as `/${P}`)\n//     : new Route(\n//       Route.ANY,\n//       path,\n//       handle,\n//     );\n//   // @ts-ignore .\n//   return route;\n// }\n\n// #pattern?: URLPattern;\n", "import { mergePath } from \"../../utils/app.ts\";\nimport { Route, RouteModule } from \"./Route.ts\";\nimport { METHOD, type RouteFetch } from \"../RoutesInit.ts\";\nimport type { Context, MergePath, Request } from \"../types.ts\";\nimport { colors } from \"../../utils.ts\";\n\ntype Options = Omit<RouteModule, \"method\" | \"fetch\">;\n\nexport class Router<\n  O extends Options = Options,\n  P extends string & O[\"path\"] = `${O[\"path\"]}`,\n> extends Route {\n  routes: Route[] = [];\n\n  constructor(\n    options?: Omit<RouteModule, \"method\" | \"fetch\">,\n  ) {\n    const { path = \"/\", ...rest } = options || {};\n    super(\n      METHOD.ANY,\n      path,\n      (req) => this.#fetch(req, req.context),\n      rest,\n    );\n  }\n\n  base<B extends string>(path: B) {\n    const mergedPath = mergePath(path, this.path) as `${MergePath<B, P>}`;\n    const router = new Router({ ...this.options, path: mergedPath });\n\n    for (const route of this.routes) {\n      router.use(route);\n    }\n\n    return router;\n  }\n\n  request(\n    input: URL | RequestInfo,\n    init?: RequestInit | undefined,\n  ) {\n    if (input instanceof Request) {\n      if (init !== undefined) {\n        input = new Request(input, init) as Request;\n      }\n\n      const context = {\n        url: new URL(input.url),\n        method: input.method as METHOD,\n        responseInit: {},\n      } as Context;\n\n      Object.assign(input, { context });\n\n      return this.fetch(input as Request, context);\n    }\n\n    input = input.toString();\n    const path = /^https?:\\/\\//.test(input)\n      ? input\n      : `http://localhost${mergePath(\"/\", input)}`;\n    const request = new Request(path, init) as Request;\n\n    const context = {\n      url: new URL(request.url),\n      method: request.method as METHOD,\n      responseInit: {},\n    } as Context;\n\n    Object.assign(request, { context });\n\n    return this.fetch(request, context);\n  }\n\n  async #fetch(request: Request, context: Context) {\n    request.context = request.context || context || Object.create(null);\n    context = request.context;\n    context.base = mergePath(context.base || \"\", context.router?.path || \"\");\n\n    context.router = this;\n\n    for (const route of this.routes) {\n      if (route.method === METHOD.ANY || request.method === route.method) {\n        const match = route.match(\n          request.method as METHOD,\n          request.url,\n          mergePath(context.base || \"\", this.path),\n        );\n\n        if (match) {\n          context.params = request.params = match;\n          context.route = route;\n\n          const response = context.responseRaw = await route.fetch(\n            request,\n            context,\n          );\n\n          if (typeof response !== \"undefined\") {\n            return response;\n          }\n        }\n      }\n    }\n  }\n\n  use<X extends P = P, R extends Route | RouteModule = Route>(\n    route: R,\n  ): Router<O, X>;\n\n  use<X extends P = P, F extends RouteFetch = RouteFetch>(\n    fetch: F,\n  ): Router<O, X>;\n\n  // use<\n  //   X extends P = P,\n  //   Path extends string = string,\n  //   H extends RouteFetch | Route = RouteFetch,\n  // >(\n  //   path: Path,\n  //   handle: H,\n  // ): Router<MergePath<X, Path>>;\n\n  use<\n    X extends P = P,\n    Path extends string = string,\n    H extends (RouteFetch | RouteModule | Route)[] = RouteFetch[],\n  >(\n    path: Path,\n    ...handlers: H\n  ): Router<O, X>;\n\n  use<\n    X extends P = P,\n    H extends (RouteFetch | RouteModule | Route)[] = RouteFetch[],\n  >(\n    ...handlers: H\n  ): Router<O, X>;\n\n  use<X extends string, H extends RouteFetch | RouteModule | Route>(\n    path: X | H,\n    handle?: H,\n  ) {\n    if (typeof path === \"string\" && handle) {\n      const route = (handle instanceof Router)\n        ? handle.base(path)\n        : (handle instanceof Route)\n        ? handle.route(path)\n        : typeof handle === \"function\"\n        ? new Route(\n          Route.ANY,\n          path,\n          handle,\n        )\n        : new Route(\n          handle.method as METHOD || METHOD.ANY,\n          handle.path || \"*\",\n          handle.fetch,\n        );\n\n      this.routes.push(route);\n    } else if (typeof path !== \"string\") {\n      const handlers = Array.from(arguments) as H[];\n      for (const handle of handlers) {\n        // handle = path;\n        if (handle instanceof Route) {\n          this.routes.push(handle);\n        } else {\n          this.routes.push(\n            typeof handle === \"function\"\n              ? new Route(METHOD.ANY, \"*\", handle)\n              : new Route(\n                handle.method as METHOD || METHOD.ANY,\n                handle.path || \"*\",\n                handle.fetch,\n              ),\n          );\n        }\n      }\n    }\n\n    return this;\n  }\n\n  get<X extends string, H extends RouteFetch | Route>(\n    path: X,\n    handle: H,\n  ): Router<O, P> {\n    if (handle instanceof Route) {\n      this.routes.push(handle.route(path));\n    } else {\n      this.routes.push(new Route(Route.GET, path, handle));\n    }\n    return this;\n  }\n\n  match(\n    input: string,\n    base?: string | undefined,\n  ): Record<string, unknown> | undefined {\n    const baseURL = /^https?:\\/\\//.test(input) ? undefined : `http://localhost`;\n\n    // const res = this.#pattern.exec(input, baseURL)?.pathname.groups;\n    const match = new URLPattern({\n      pathname: mergePath(base || \"\", this.path, \"/*\"),\n    }).exec(input, baseURL)?.pathname.groups;\n\n    const ident = \"\\n     @ \";\n    console.log(\n      `${ident}${colors.blue(this.constructor.name)}( [${\n        colors.gray(base || \"/\")\n      }${colors.blue(this.path)}] ).match( ${input} ) =>`,\n      match,\n    );\n    return match;\n  }\n}\n\n// const logger = <T extends string>(tag: T): RouteFetch =>\n//   function logger(req) {\n//     console.log(\n//       `(${tag})`,\n//       req.url,\n//       req.params,\n//       //   \"\\n\",\n//       //   req.context.router,\n//     );\n//   };\n\n// const user = new Router(\"/user\")\n//   .get(\"/\", () => \"User Home\")\n//   .get(\"/:id\", (req) => `User id=${req.params.id}`)\n//   .use(\n//     \"/x\",\n//     new Router(\"/posts\").get(\n//       \"/:post_id\",\n//       (req) => \"User Post \" + req.url,\n//     ),\n//   )\n//   .use(\"/y\", new Route(Route.ANY, \"/test\", () => \"y test\"));\n\n// const blog = new Router(\"/blog\")\n//   //   .use(logger(\"blog\"))\n//   .use(user)\n//   .get(\"/posts\", () => \"Blog Posts\")\n//   .get(\"/post/:id\", (req) => \"Blog Post #\" + req.params.id)\n//   .use(user.base(\"/admin\"));\n// // .use();\n\n// const app = new Router(\"/test\")\n//   .use(logger(\"test\"))\n//   .use(\"/about1\", () => \"Hola\")\n//   //   .base(\"/xxx\")\n//   .use(\"/about2\", () => \"Hola\");\n// //   .use(\"xx\", blog);\n\n// // const res = await blog.request(\"/test/xx/blog/posts\");\n\n// console.log(\"res\", await blog.request(\"/blog/admin/user/y/test\"));\n", "import type { RouteModule } from \"./Route.ts\";\nimport { Router } from \"./Router.ts\";\n\nexport type AppOptions = Omit<RouteModule, \"method\" | \"fetch\">;\n\nexport class App extends Router {}\n\nexport function tapp(\n  options?: AppOptions,\n) {\n  return new App(options);\n}\n", "import { RouteFetch } from \"../RoutesInit.ts\";\nimport { EventSourceMessage } from \"../ess/EventSourceMessage.ts\";\nimport { Route } from \"./Route.ts\";\n\nexport const get = (path: string, fetch: RouteFetch) =>\n  new Route(Route.GET, path, fetch);\n\nexport const put = (path: string, fetch: RouteFetch) =>\n  new Route(Route.PUT, path, fetch);\n\nexport const post = (path: string, fetch: RouteFetch) =>\n  new Route(Route.POST, path, fetch);\n\nexport const options = (path: string, fetch: RouteFetch) =>\n  new Route(Route.OPTIONS, path, fetch);\n\nexport const del = (path: string, fetch: RouteFetch) =>\n  new Route(Route.DELETE, path, fetch);\n\nexport enum Mime {\n  html = \"text/html\",\n  text = \"text/plain\",\n  eventStream = \"text/event-stream\",\n  js = \"application/javascript\",\n}\n\nexport const send = (\n  body?: BodyInit | null | undefined,\n  init?: Mime | ResponseInit | undefined,\n) =>\n  new Response(\n    body,\n    typeof init === \"string\" ? { headers: { \"content-type\": init } } : init,\n  );\n\nsend.js = (body: BodyInit) => send(body, Mime.js);\nsend.html = (body: BodyInit) => send(body, Mime.html);\nsend.text = (body: BodyInit) => send(body, Mime.text);\nsend.eventStream = (body: BodyInit) => send(body, Mime.eventStream);\nsend.stream = (body: ReadableStream) =>\n  send(body.pipeThrough(transform.toUint8Array()), Mime.eventStream);\n\nsend.sse = <T extends EventSourceMessage>(stream: ReadableStream<T>) => {\n  const body = stream.pipeThrough(transform.sse());\n\n  return new Response(body, {\n    headers: {\n      \"content-type\": \"text/event-stream\",\n      \"cache-control\": \"no-cache\",\n    },\n  });\n};\n", "{\n  \"name\": \"@clappcodes/transporter\",\n  \"version\": \"0.2.7\",\n  \"exports\": \"./mod.ts\",\n  \"tasks\": {\n    \"dev\": \"DEBUG=false deno run -A --inspect --env --watch main.ts\",\n    \"run\": \"deno run -A --watch --env --inspect=127.0.0.1:9229 run.ts\",\n    \"serve\": \"deno run -A --env --watch --inspect=127.0.0.1:9230 serve.ts\",\n    \"bundle\": \"deno run -A ./.tools/bundle.ts\",\n    \"npm:build\": \"deno run -A ./.tools/npm.build.ts\",\n    \"npm:publish\": \"deno run -A ./.tools/npm.publish.ts\",\n    \"safe\": \"deno fmt && deno lint && deno check mod.ts\",\n    \"pub\": \"deno task safe && deno task bundle && deno task npm:publish && deno publish --allow-dirty\",\n    \"deploy\": \"deno task safe && deno task bundle && deployctl deploy --prod\",\n    \"install\": \"deno install -f -A --name serve --env serve.ts --\"\n  },\n  \"exclude\": [\n    \".npm\",\n    \".bundle\"\n  ],\n  \"compilerOptions\": {\n    \"lib\": [\n      \"deno.window\",\n      \"dom\"\n    ]\n  },\n  \"deploy\": {\n    \"project\": \"98ab1ab7-5378-473f-9ac8-12d09564c492\",\n    \"name\": \"transporter\",\n    \"exclude\": [\n      \"**/node_modules\",\n      \".npm\"\n    ],\n    \"include\": [],\n    \"entrypoint\": \"main.ts\"\n  }\n}", "import {\n  JSONDecoderStream,\n  JSONEncoderStream,\n  PipeStream,\n  Transformers,\n} from \"../transport/mod.ts\";\nimport { isTransformStream } from \"../utils.ts\";\n\ntype JSONSchema = { uid: string; msg: string };\n\nconst writeMessage = (x = \"-\") =>\n  transform.tap<JSONSchema>((o) => console.log(`${x} ${o.uid}: ${o.msg}`));\n\nclass JSONStream extends PipeStream<JSONSchema, JSONSchema> {\n  uid = \"client\" as const;\n  constructor(input: URL | RequestInfo) {\n    super(\n      writeMessage(\">\"),\n      new JSONEncoderStream(),\n      new TextEncoderStream(),\n      new Transporter(input),\n      new TextDecoderStream(),\n      new JSONDecoderStream(),\n      writeMessage(\"<\"),\n    );\n  }\n  send(msg: JSONSchema[\"msg\"]) {\n    return this.write({ uid: this.uid, msg });\n  }\n}\n\nclass JSONRequestStream extends PipeStream<Uint8Array, JSONSchema> {\n  constructor(public request: Request) {\n    super(\n      new TextDecoderStream(),\n      new JSONDecoderStream(),\n      writeMessage(\">\"),\n    );\n    request.body?.pipeTo(this.writable);\n  }\n}\n\nclass JSONResponseStream extends PipeStream<JSONSchema, Uint8Array> {\n  uid = \"server\" as const;\n  constructor(public init?: ResponseInit) {\n    super(\n      writeMessage(\"<\"),\n      new JSONEncoderStream(),\n      new TextEncoderStream(),\n    );\n  }\n\n  send(msg: JSONSchema[\"msg\"]) {\n    return this.write({ uid: this.uid, msg });\n  }\n}\n\nclass JSONTransportStream extends Response {\n  writable: WritableStream<JSONSchema>;\n  readable: ReadableStream<JSONSchema>;\n\n  write: (message: JSONSchema) => Promise<void>;\n  read: (cb: (chunk: JSONSchema) => void) => Promise<void>;\n\n  send: (msg: string) => Promise<void>;\n\n  constructor(public request: Request, public responseInit?: ResponseInit) {\n    const _request = new JSONRequestStream(request);\n    const _response = new JSONResponseStream();\n\n    super(_response.readable, responseInit);\n\n    this.headers.set(\"content-type\", \"text/event-stream\");\n\n    this.writable = _response.writable;\n    this.write = _response.write.bind(_response);\n    this.send = _response.send.bind(_response);\n\n    this.readable = _request.readable;\n    this.read = _request.read.bind(_request);\n  }\n  pipeTo(\n    destination: TransformStream<JSONSchema> | WritableStream<JSONSchema>,\n  ) {\n    return this.readable.pipeTo(\n      isTransformStream(destination) ? destination.writable : destination,\n    );\n  }\n\n  pipe(...transformers: Transformers) {\n    return this.readable.pipeThrough(new PipeStream(...transformers));\n  }\n}\n\nexport const jsonStream =\n  (fn: (i: JSONTransportStream) => unknown) => (req: Request) => {\n    const res = new JSONTransportStream(req);\n    if (typeof fn === \"function\") {\n      fn(res);\n    }\n    return res;\n  };\n\nexport default {\n  init(url: string = \"/pipe1\") {\n    const ts = new JSONStream(url);\n\n    ts.read(console.log);\n    ts.send(\"Hello Server\");\n\n    return ts;\n  },\n  fetch3: jsonStream((stream) =>\n    stream.pipe(transform.tap(console.warn)).pipeTo(stream.writable)\n  ),\n  fetch: jsonStream((stream) => {\n    // stream.pipeTo(stream);\n\n    // @ts-ignore .\n    globalThis.p1 = stream;\n\n    stream.read((o) => {\n      if (o.uid === \"xxx\") {\n        stream.send(`hey ${o.uid}, \n            what is this: ${o.msg}?`);\n      }\n    });\n\n    stream.write({ uid: \"deno\", msg: \"Hi\" });\n\n    return stream;\n  }),\n};\n", "import { bold, gray, red } from \"./colors.ts\";\nimport * as transporter from \"./mod.ts\";\n\nimport type * as TransportTypes from \"./transport/types.ts\";\n\nimport pipe1 from \"./playground/pipe1.ts\";\n\nObject.assign(globalThis, { pipe1 });\n\nconsole.log(\n  \"\\n\\t\" +\n    bold(red(transporter.package.name)) + \" \" +\n    gray(transporter.package.version) + \"\\n\\n\",\n);\n\n// const table = {\n//   readable: Object.keys(transporter.readable),\n//   writable: Object.keys(transporter.writable),\n//   transform: Object.keys(transporter.transform),\n// };\n\n// console.log(table);\n\nconst {\n  Route,\n  Router,\n  App,\n  tapp,\n  fetchDuplex,\n  fetchStream,\n  get,\n  send,\n  put,\n  post,\n  duplex,\n  ess,\n  TransportStream,\n  Transporter,\n  TextTransporter,\n  EventSourceTransporter,\n  JSONTransporter,\n  RequestDuplex,\n  RequestStream,\n  PipeStream,\n} = transporter.transport;\n\nObject.assign(globalThis, transporter, ess, {\n  TransportStream,\n  PipeStream,\n  Transporter,\n  TextTransporter,\n  EventSourceTransporter,\n  JSONTransporter,\n  RequestDuplex,\n  RequestStream,\n  transporter,\n  readable: Object.assign(transporter.readable.readable, transporter.readable),\n  Route,\n  ess,\n  Router,\n  App,\n  tapp,\n  fetchDuplex,\n  fetchStream,\n  duplex,\n  get,\n  send,\n  put,\n  post,\n});\n\ndeclare global {\n  const readable: typeof transporter.readable;\n  const writable: typeof transporter.writable;\n  const transform: typeof transporter.transform;\n  const transport: typeof transporter.transport;\n  class Transporter extends transporter.transport.Transporter {}\n  // const tapp: typeof transport.tapp;\n\n  // const Transporter: typeof transporter;\n  // type Transporter = typeof transporter;\n\n  // type Transport = typeof transporter.transport\n\n  // namespace Transporter {\n  //   const readable: typeof transporter.readable;\n  //   const writable: typeof transporter.writable;\n  //   const transform: typeof transporter.transform;\n  //   const transport: typeof transporter.transport;\n  // }\n\n  namespace TApp {\n    interface Serve extends TransportTypes.Serve {}\n    interface Request extends TransportTypes.Request {\n      params: Record<string, string | undefined>;\n    }\n    interface Context extends TransportTypes.Context {}\n    interface Handler extends TransportTypes.ServeHandler {}\n  }\n}\n\nexport {};\n"],
  "mappings": "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",
  "names": ["Deno", "code", "mod_exports", "readable", "mod_exports", "options", "readable", "fn", "readable", "mod_exports", "readable", "writable", "response", "writable", "mod_exports", "log", "transform", "isTransformStream", "mod_exports", "write", "response", "fetch", "alphaMap", "options", "response", "mod_exports", "read", "headers", "ReadyState", "delay", "transform", "readable", "writable", "readable2", "message", "cb", "write", "isTransformStream", "transform", "isTransformStream", "mapper", "log", "fd", "alphaMap", "encoder", "pipe", "readable", "isTransformStream", "writable", "readable", "pipe", "to", "reset", "transform", "mod_exports", "RequestStream", "TransportStream", "Transporter", "pipe", "post", "METHOD", "STREAM_TYPE", "response", "mod_exports", "fetch", "Transporter", "response", "decoder", "encoder", "readable", "writable", "Transporter", "RequestStream", "Transporter", "mod_exports", "init", "ess", "Transporter", "writable", "readable", "TransportStream", "readable", "demo", "response", "fetch", "options", "response", "options", "context", "response", "handle", "options", "fetch", "post", "Mime", "x", "isTransformStream", "Route", "Router", "App", "tapp", "fetchDuplex", "fetchStream", "get", "send", "put", "post", "duplex", "TransportStream", "Transporter", "TextTransporter", "EventSourceTransporter", "JSONTransporter", "RequestDuplex", "RequestStream", "PipeStream", "mod_exports"]
}
